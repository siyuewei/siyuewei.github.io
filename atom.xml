<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://siyuewei.github.io/atom.xml" rel="self"/>
  
  <link href="https://siyuewei.github.io/"/>
  <updated>2025-11-16T08:15:34.689Z</updated>
  <id>https://siyuewei.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Delegate以及延申</title>
    <link href="https://siyuewei.github.io/2025/11/14/C#/Delegate%E4%BB%A5%E5%8F%8A%E5%BB%B6%E7%94%B3/"/>
    <id>https://siyuewei.github.io/2025/11/14/C#/Delegate%E4%BB%A5%E5%8F%8A%E5%BB%B6%E7%94%B3/</id>
    <published>2025-11-14T10:21:20.000Z</published>
    <updated>2025-11-16T08:15:34.689Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本关系介绍"><a href="#基本关系介绍" class="headerlink" title="基本关系介绍"></a>基本关系介绍</h1><p>Delegate类似一个函数的类型声明，与之相关的内容有Func，Action，Event，UnityEvent。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────┐</span><br><span class="line">│     delegate (C# 的基础特性)         │  ← 最底层</span><br><span class="line">└─────────────────┬───────────────────┘</span><br><span class="line">                  │</span><br><span class="line">        ┌─────────┴─────────┐</span><br><span class="line">        ↓                   ↓</span><br><span class="line">┌─────────────┐      ┌─────────────┐</span><br><span class="line">│ Func/Action │      │ 自定义delegate│</span><br><span class="line">│  (C# 内置)  │      │  (你定义的) │</span><br><span class="line">└──────┬──────┘      └──────┬──────┘</span><br><span class="line">       │                    │</span><br><span class="line">       └────────┬───────────┘</span><br><span class="line">                ↓</span><br><span class="line">        ┌─────────────┐</span><br><span class="line">        │    event    │  ← 关键字，不是类型</span><br><span class="line">        │  (访问限制)  │</span><br><span class="line">        └──────┬──────┘</span><br><span class="line">               │</span><br><span class="line">               ↓</span><br><span class="line">        ┌─────────────┐</span><br><span class="line">        │ UnityEvent  │  ← Unity 特有封装</span><br><span class="line">        │(Unity特有)  │</span><br><span class="line">        └─────────────┘</span><br></pre></td></tr></table></figure><table><thead><tr><th>名称</th><th>类型&#x2F;关键字</th><th>来源</th><th>用途</th><th>Inspector可见</th></tr></thead><tbody><tr><td><code>delegate</code></td><td>关键字</td><td>C#</td><td>定义委托类型</td><td>❌</td></tr><tr><td><code>Func</code></td><td>预定义委托</td><td>C#&#x2F;.NET</td><td>有返回值的通用委托</td><td>❌</td></tr><tr><td><code>Action</code></td><td>预定义委托</td><td>C#&#x2F;.NET</td><td>无返回值的通用委托</td><td>❌</td></tr><tr><td><code>event</code></td><td>关键字&#x2F;修饰符</td><td>C#</td><td>封装委托，限制访问</td><td>❌</td></tr><tr><td><code>UnityEvent</code></td><td>类</td><td>Unity</td><td>Unity封装的事件系统</td><td>✅</td></tr></tbody></table><h1 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h1><h2 id="1-delegate-C-的基础特性"><a href="#1-delegate-C-的基础特性" class="headerlink" title="1. delegate - C#的基础特性"></a>1. delegate - C#的基础特性</h2><p><strong>定义</strong>：函数的类型定义，是对函数签名（输入参数+返回值）的抽象</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义委托类型（就像定义一个类型）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">Calculator</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 定义符合委托签名的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Multiply</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 使用委托</span></span><br><span class="line">Calculator calc = Add;           <span class="comment">// 将方法赋值给委托变量</span></span><br><span class="line"><span class="built_in">int</span> result = calc(<span class="number">5</span>, <span class="number">3</span>);         <span class="comment">// 调用委托，结果为 8</span></span><br><span class="line"></span><br><span class="line">calc = Multiply;                 <span class="comment">// 更换为另一个方法</span></span><br><span class="line">result = calc(<span class="number">5</span>, <span class="number">3</span>);             <span class="comment">// 调用委托，结果为 15</span></span><br></pre></td></tr></table></figure><h2 id="2-Func和Action-C-预定义的泛型委托"><a href="#2-Func和Action-C-预定义的泛型委托" class="headerlink" title="2. Func和Action - C#预定义的泛型委托"></a>2. Func和Action - C#预定义的泛型委托</h2><ul><li>Func和Action都是C#基于Delegate预先定义好的类型</li><li>主要区别在于Func是有返回值的，Action是没有返回值的</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">它们在.NET Framework/Core中的定义类似下面</span><br><span class="line"></span><br><span class="line">//Action：无返回值的委托</span><br><span class="line">public delegate void Action();</span><br><span class="line">public delegate void Action&lt;T&gt;(T arg);</span><br><span class="line">public delegate void Action&lt;T1,T2&gt;(T1 arg1,T2 args);</span><br><span class="line">//...最多16个参数</span><br><span class="line"></span><br><span class="line">//Func：有返回值的委托，最后一个参数是返回值</span><br><span class="line">public delegate TResult Func&lt;TResult&gt;();</span><br><span class="line">public delegate TResult Func&lt;T,TResult&gt;(T arg);</span><br><span class="line">public delegate TResult Func&lt;T1,T2,TResult&gt;(T1 arg1,T2 arg2);</span><br><span class="line">//...最多16个参数+1个返回值</span><br></pre></td></tr></table></figure><h2 id="3-event-C-的访问控制关键字"><a href="#3-event-C-的访问控制关键字" class="headerlink" title="3. event - C#的访问控制关键字"></a>3. event - C#的访问控制关键字</h2><ul><li>event不是一个类型，它是修饰符关键字</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public delegate void Action(); //C#中已有代码，不需要我们再写</span><br><span class="line">public event Action myAction;  //event修饰Action</span><br><span class="line"></span><br><span class="line">public delegate int MyDelegate(bool b); //自己随便定义的委托</span><br><span class="line">public event MyDelegate myDelegate; //event修饰自定义的委托</span><br></pre></td></tr></table></figure><p>有无event的对比：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//没有event，外部可以随机操作</span><br><span class="line">public delegate int MyDelegate(bool b);</span><br><span class="line">public MyDelegate myDelegate;</span><br><span class="line"></span><br><span class="line">//外部代码可以：</span><br><span class="line">obj.myDelegate += Handler;  // ✅ 订阅</span><br><span class="line">obj.myDelegate -= Handler;  // ✅ 取消订阅</span><br><span class="line">obj.myDelegate();           // ❌ 但也能直接调用！</span><br><span class="line">obj.myDelegate = null;      // ❌ 甚至能清空所有订阅者！</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">有event修饰，外部的访问权限部分被限制</span><br><span class="line">public delegate int MyDelegate(bool b);</span><br><span class="line">public MyDelegate myDelegate;</span><br><span class="line"></span><br><span class="line">//外部代码只能：</span><br><span class="line">obj.myDelegate += Handler;  // ✅ 订阅</span><br><span class="line">obj.myDelegate -= Handler;  // ✅ 取消订阅</span><br><span class="line">obj.myDelegate();           // ❌ 编译错误！不能调用</span><br><span class="line">obj.myDelegate = null;      // ❌ 编译错误！不能赋值</span><br></pre></td></tr></table></figure><h2 id="4-UnityEvent-Unity特有的封装事件类"><a href="#4-UnityEvent-Unity特有的封装事件类" class="headerlink" title="4. UnityEvent - Unity特有的封装事件类"></a>4. UnityEvent - Unity特有的封装事件类</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">using UnityEngine.Events; //Unity特有的命名空间</span><br><span class="line"></span><br><span class="line">//UnityEvent是Unity封装的事件类</span><br><span class="line">public UnityEvent onButtonClick;       //无参数</span><br><span class="line">public UnityEvent&lt;int&gt; onScoreChanged; //带参数</span><br></pre></td></tr></table></figure><ul><li>Unity特有，不是C#标准</li><li>可以在inspector窗口中可视化配置</li><li>可以序列化</li><li>使用反射，性能比较差</li></ul><h3 id="UnityEvent使用反射"><a href="#UnityEvent使用反射" class="headerlink" title="UnityEvent使用反射"></a>UnityEvent使用反射</h3><h4 id="1-Inspector配置中的反射"><a href="#1-Inspector配置中的反射" class="headerlink" title="1.Inspector配置中的反射"></a>1.Inspector配置中的反射</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line">using UnityEngine.Events;</span><br><span class="line"></span><br><span class="line">public class MyButton : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    public UnityEvent onClick;  // 在 Inspector 中可见</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Inspector 做的事情：</p><ul><li>使用反射扫描 GameObject 上的所有组件</li><li>使用反射获取每个组件的所有 public 方法</li><li>展示在下拉列表中供你选择</li></ul><h4 id="2-运行时的反射调用"><a href="#2-运行时的反射调用" class="headerlink" title="2.运行时的反射调用"></a>2.运行时的反射调用</h4><p>Unity 将 Inspector 配置序列化存储：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储的配置信息（字符串形式）</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;target&quot;</span>: ScoreManager 组件引用,</span><br><span class="line">    <span class="string">&quot;methodName&quot;</span>: <span class="string">&quot;UpdateScore&quot;</span>,</span><br><span class="line">    <span class="string">&quot;argument&quot;</span>: <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用 <code>onClick.Invoke()</code> 时，Unity 读取这些配置并使用反射调用：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简化的内部实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Invoke</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 获取 Inspector 配置的目标对象和方法名</span></span><br><span class="line">    Object target = config.target;</span><br><span class="line">    <span class="built_in">string</span> methodName = config.methodName;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 使用反射获取方法</span></span><br><span class="line">    Type type = target.GetType();</span><br><span class="line">    MethodInfo method = type.GetMethod(methodName);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 使用反射调用方法</span></span><br><span class="line">    method.Invoke(target, <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; config.argument &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>一般而言，Delegate有以下使用场景：</p><ul><li><p>事件系统：</p><ul><li>event Action         ████████████████████ 80%  (最常用)</li><li>event 自定义delegate  ████████ 20%</li></ul></li><li><p>回调&#x2F;策略：</p><ul><li>Func&#x2F;Action          ████████████ 60%</li><li>自定义 delegate       ████████ 40</li></ul></li><li><p>有返回值的多播（一般来说可能是验证链）：</p><ul><li>自定义 delegate + 手动处理 GetInvocationList</li></ul></li></ul><h2 id="1-事件系统"><a href="#1-事件系统" class="headerlink" title="1.事件系统"></a>1.事件系统</h2><p>优先event Action，当参数很多，需要参数名提高可读性的时候，会用到自定义delegate</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 当参数很多，需要参数名提高可读性时</span><br><span class="line">public delegate void OnTowerUpgraded(</span><br><span class="line">    TowerActor tower,</span><br><span class="line">    int oldLevel,</span><br><span class="line">    int newLevel,</span><br><span class="line">    UpgradeType type,</span><br><span class="line">    float cost</span><br><span class="line">);</span><br><span class="line">public event OnTowerUpgraded onTowerUpgraded;</span><br><span class="line"></span><br><span class="line">// 对比 Action：</span><br><span class="line">public event Action&lt;TowerActor, int, int, UpgradeType, float&gt; onTowerUpgraded;</span><br><span class="line">// ❌ 看不懂每个参数的含义</span><br></pre></td></tr></table></figure><h2 id="2-回调-策略"><a href="#2-回调-策略" class="headerlink" title="2.回调&#x2F;策略"></a>2.回调&#x2F;策略</h2><p>简单场景，使用 Func&#x2F;Action</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// ✅ 简单回调用 Func/Action</span><br><span class="line">public void LoadAsync(string url, Action&lt;string&gt; onSuccess)</span><br><span class="line">&#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void ProcessData(Func&lt;int, int&gt; transformer)</span><br><span class="line">&#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// LINQ 风格</span><br><span class="line">public List&lt;T&gt; Filter&lt;T&gt;(List&lt;T&gt; list, Func&lt;T, bool&gt; predicate)</span><br><span class="line">&#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>领域概念&#x2F;复杂场景 → 自定义 delegate</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// ✅ 表达领域概念用自定义 delegate</span><br><span class="line">public delegate EnemyActor TargetingLogicFuncType(</span><br><span class="line">    List&lt;EnemyActor&gt; enemies,</span><br><span class="line">    TowerActor tower</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">private Dictionary&lt;TargetingType, TargetingLogicFuncType&gt; _logics;</span><br><span class="line"></span><br><span class="line">// 对比 Func：</span><br><span class="line">private Dictionary&lt;TargetingType, Func&lt;List&lt;EnemyActor&gt;, TowerActor, EnemyActor&gt;&gt; _logics;</span><br><span class="line">// ❌ 太长，可读性差</span><br></pre></td></tr></table></figure><h2 id="3-多播-验证链（有返回值）"><a href="#3-多播-验证链（有返回值）" class="headerlink" title="3.多播 - 验证链（有返回值）"></a>3.多播 - 验证链（有返回值）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class ValidationSystem</span><br><span class="line">&#123;</span><br><span class="line">    // ✅ 有返回值，不用 event</span><br><span class="line">    public delegate bool Validator(string input);</span><br><span class="line">    public Validator validators;  // ⚠️ 没有 event 关键字</span><br><span class="line">    </span><br><span class="line">    // 也可以用 Func（少见）</span><br><span class="line">    // public Func&lt;string, bool&gt; validators;</span><br><span class="line">    </span><br><span class="line">    public bool ValidateAll(string input)</span><br><span class="line">    &#123;</span><br><span class="line">        if (validators == null) return true;</span><br><span class="line">        </span><br><span class="line">        // 手动处理所有返回值</span><br><span class="line">        foreach (Validator v in validators.GetInvocationList())</span><br><span class="line">        &#123;</span><br><span class="line">            if (!v(input))</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.Log($&quot;验证失败：&#123;v.Method.Name&#125;&quot;);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用</span><br><span class="line">validationSystem.validators += ValidateLength;</span><br><span class="line">validationSystem.validators += ValidateFormat;</span><br><span class="line">bool isValid = validationSystem.ValidateAll(&quot;test@email.com&quot;);</span><br></pre></td></tr></table></figure><p>有返回值的多播，通常不加 event，需要手动控制调用逻辑。其实在代码上没有任何问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class ValidationSystem</span><br><span class="line">&#123;</span><br><span class="line">    public delegate bool Validator(string input);</span><br><span class="line">    public event Validator validators;  // ✅ 封装良好</span><br><span class="line">    </span><br><span class="line">    // 必须提供方法</span><br><span class="line">    public bool ValidateAll(string input)</span><br><span class="line">    &#123;</span><br><span class="line">        if (validators == null) return true;</span><br><span class="line">        foreach (Validator v in validators.GetInvocationList())</span><br><span class="line">        &#123;</span><br><span class="line">            if (!v(input)) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是语义怪异（event 暗示”事件”），违反开发者直觉，必须提供包装方法</p><p>实际上是一种约定俗成</p><p>如果要实现event那种封装，可以用其他的办法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class ValidationSystem</span><br><span class="line">&#123;</span><br><span class="line">    public delegate bool Validator(string input);</span><br><span class="line">    private Validator _validators;  // ✅ 私有化</span><br><span class="line">    </span><br><span class="line">    // 提供受控的订阅接口</span><br><span class="line">    public void AddValidator(Validator validator)</span><br><span class="line">    &#123;</span><br><span class="line">        _validators += validator;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void RemoveValidator(Validator validator)</span><br><span class="line">    &#123;</span><br><span class="line">        _validators -= validator;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 提供调用接口</span><br><span class="line">    public bool ValidateAll(string input)</span><br><span class="line">    &#123;</span><br><span class="line">        if (_validators == null) return true;</span><br><span class="line">        foreach (Validator v in _validators.GetInvocationList())</span><br><span class="line">        &#123;</span><br><span class="line">            if (!v(input)) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本关系介绍&quot;&gt;&lt;a href=&quot;#基本关系介绍&quot; class=&quot;headerlink&quot; title=&quot;基本关系介绍&quot;&gt;&lt;/a&gt;基本关系介绍&lt;/h1&gt;&lt;p&gt;Delegate类似一个函数的类型声明，与之相关的内容有Func，Action，Event，UnityEve</summary>
      
    
    
    
    <category term="C#" scheme="https://siyuewei.github.io/categories/C/"/>
    
    
    <category term="C#" scheme="https://siyuewei.github.io/tags/C/"/>
    
    <category term="Unity" scheme="https://siyuewei.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>C#基本概念汇总</title>
    <link href="https://siyuewei.github.io/2025/10/30/C#/C#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E6%B1%87%E6%80%BB/"/>
    <id>https://siyuewei.github.io/2025/10/30/C#/C#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E6%B1%87%E6%80%BB/</id>
    <published>2025-10-30T10:48:20.000Z</published>
    <updated>2025-10-30T12:28:18.884Z</updated>
    
    <content type="html"><![CDATA[<h1 id="创建属性"><a href="#创建属性" class="headerlink" title="创建属性"></a>创建属性</h1><p>属性本质上是对变量的 get 和 set 访问器的封装。</p><p>对于需要公开访问的字段，直接使用 public 修饰符存在安全隐患，而使用属性可以带来以下优势：</p><ol><li>保护私有数据不被直接修改</li><li>在 get 和 set 访问器中进行安全检测</li><li>支持定义只读或只写属性</li></ol><p>此外，属性也可以理解为两个方法的组合。例如下面的 Level 属性，实际上就是提供了两个方法来修改或获取内部的 experience 数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class PlayerController</span><br><span class="line">&#123;</span><br><span class="line">    private int experience;</span><br><span class="line"></span><br><span class="line">    public int Experience</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            return experience;</span><br><span class="line">        &#125;</span><br><span class="line">        set</span><br><span class="line">        &#123;</span><br><span class="line">            experience = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int Level</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            return experience / 1000;</span><br><span class="line">        &#125;</span><br><span class="line">        set</span><br><span class="line">        &#123;</span><br><span class="line">            experience = value * 1000;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int Health &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h2><ul><li><p>在接口中：{ get; set; } 是一个抽象声明，它不包含任何实现或数据存储。它强制实现类去提供实现。</p></li><li><p>在类中：{ get; set; } 是一个完整的实现，它自动为数据存储和访问逻辑。</p></li></ul><h1 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h1><p>C# 支持单继承，子类可以通过 <code>base</code> 关键字访问父类的成员。</p><p>虚函数（Virtual Function）是实现多态的核心机制：</p><ul><li>父类使用 <code>virtual</code> 关键字声明可被重写的方法</li><li>子类使用 <code>override</code> 关键字重写父类的虚方法</li></ul><p><strong>关键特性</strong>：当子类对象被强制转换为父类类型时，只能访问父类定义的成员，但调用虚函数时仍会执行子类重写的版本，这体现了运行时多态。</p><p>代码示例如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类：定义基础行为</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Actor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _health;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 属性：封装健康值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Health</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _health; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; _health = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 虚方法：可被子类重写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Move</span>(<span class="params"><span class="built_in">float</span> x, <span class="built_in">float</span> y</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Actor is moving to: &quot;</span> + x + <span class="string">&quot;, &quot;</span> + y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类：继承并扩展父类功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerController</span> : <span class="title">Actor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 子类特有的属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> jumpHeight;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PlayerController</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        jumpHeight = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重写父类的虚方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Move</span>(<span class="params"><span class="built_in">float</span> x, <span class="built_in">float</span> y</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;PlayerController is moving to: &quot;</span> + x + <span class="string">&quot;, &quot;</span> + y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类：演示多态行为</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestPlayer</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            PlayerController player = <span class="keyword">new</span> PlayerController();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 通过子类引用调用</span></span><br><span class="line">            player.Move(<span class="number">5.0f</span>, <span class="number">10.0f</span>);           <span class="comment">// 输出：PlayerController is moving to: 5, 10</span></span><br><span class="line">            Debug.Log(player.jumpHeight);        <span class="comment">// 输出：2（子类特有属性可访问）</span></span><br><span class="line">            Debug.Log(player.Health);            <span class="comment">// 输出：0（继承自父类的属性）</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将子类对象强转为父类类型</span></span><br><span class="line">            Actor actor = (Actor)player;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 虚方法调用：仍然执行子类的重写版本（多态）</span></span><br><span class="line">            actor.Move(<span class="number">15.0f</span>, <span class="number">20.0f</span>);           <span class="comment">// 输出：PlayerController is moving to: 15, 20</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 子类特有成员无法访问（编译错误）</span></span><br><span class="line">            <span class="comment">// Debug.Log(actor.jumpHeight);      // 错误：Actor 类型没有 jumpHeight 成员</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="成员隐藏"><a href="#成员隐藏" class="headerlink" title="成员隐藏"></a>成员隐藏</h1><p>成员隐藏（Member Hiding）是通过 <code>new</code> 关键字在子类中重新定义父类的成员或方法，从而”隐藏”父类的实现。</p><p><strong>核心区别</strong>：</p><ul><li><strong>虚函数（多态）</strong>：使用 <code>virtual</code> 和 <code>override</code>，强转后调用的是子类重写的方法</li><li><strong>成员隐藏</strong>：使用 <code>new</code> 关键字，强转后调用的是父类原有的方法</li></ul><p><strong>行为特点</strong>：当子类对象被强制转换为父类类型时，调用的成员或方法都是父类的版本，而非子类隐藏的版本。这是因为成员隐藏是编译时绑定，而非运行时多态。</p><p>代码示例如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Warrior</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> damage = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 普通方法（非虚方法）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Attack</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Warrior attacks with damage: &quot;</span> + damage);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Defend</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Warrior defends!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类：使用 new 关键字隐藏父类成员</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Paladin</span> : <span class="title">Warrior</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使用 new 隐藏父类的字段</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">new</span> <span class="built_in">int</span> damage = <span class="number">20</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 new 隐藏父类的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">new</span> <span class="keyword">void</span> <span class="title">Attack</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Paladin attacks with holy damage: &quot;</span> + damage);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">new</span> <span class="keyword">void</span> <span class="title">Defend</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Paladin defends with shield!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类：对比成员隐藏的行为</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestHiding</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Paladin paladin = <span class="keyword">new</span> Paladin();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 通过子类引用访问</span></span><br><span class="line">            Debug.Log(paladin.damage);      <span class="comment">// 输出：20（访问子类的 damage）</span></span><br><span class="line">            paladin.Attack();                <span class="comment">// 输出：Paladin attacks with holy damage: 20</span></span><br><span class="line">            paladin.Defend();                <span class="comment">// 输出：Paladin defends with shield!</span></span><br><span class="line">            </span><br><span class="line">            Debug.Log(<span class="string">&quot;--- 强转为父类后 ---&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将子类对象强转为父类类型</span></span><br><span class="line">            Warrior warrior = (Warrior)paladin;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 关键：强转后访问的是父类的成员（编译时绑定）</span></span><br><span class="line">            Debug.Log(warrior.damage);       <span class="comment">// 输出：10（访问父类的 damage）</span></span><br><span class="line">            warrior.Attack();                <span class="comment">// 输出：Warrior attacks with damage: 10</span></span><br><span class="line">            warrior.Defend();                <span class="comment">// 输出：Warrior defends!</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 注意：虽然 warrior 和 paladin 引用的是同一个对象，</span></span><br><span class="line">            <span class="comment">// 但由于使用了 new 隐藏而非 override 重写，</span></span><br><span class="line">            <span class="comment">// 所以通过父类引用调用的是父类版本的方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong>：</p><ul><li>成员隐藏打破了多态性，调用哪个版本取决于引用类型而非对象类型</li><li>如果需要多态行为，应使用 <code>virtual</code> 和 <code>override</code></li><li><code>new</code> 关键字主要用于有意隐藏父类成员，或解决命名冲突</li></ul><h1 id="接口（Interface）"><a href="#接口（Interface）" class="headerlink" title="接口（Interface）"></a>接口（Interface）</h1><p>接口是一种定义契约的方式，只包含成员的声明，不包含任何实现。实现接口的类必须提供所有成员的具体实现。</p><p><strong>接口的特点</strong>：</p><ul><li>只包含方法、属性、事件和索引器的声明，不包含实现</li><li>接口成员默认是 <code>public</code> 的，不需要显式声明访问修饰符</li><li>一个类可以实现多个接口，弥补 C# 单继承的限制</li><li>接口支持多态，通过接口引用可以调用不同实现类的方法</li></ul><p><strong>属性与接口</strong>：属性可以定义在接口中，因为属性本质上就是 <code>get</code> 和 <code>set</code> 方法的声明。接口可以要求实现类提供特定的属性访问器。</p><h2 id="接口属性的本质与演进"><a href="#接口属性的本质与演进" class="headerlink" title="接口属性的本质与演进"></a>接口属性的本质与演进</h2><h3 id="传统接口（C-8-0-之前）"><a href="#传统接口（C-8-0-之前）" class="headerlink" title="传统接口（C# 8.0 之前）"></a>传统接口（C# 8.0 之前）</h3><p>在 C# 8.0 之前，接口<strong>只能包含声明，不能包含实现</strong>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统接口：只有抽象声明</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IWeapon</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这是抽象属性声明，不是实现</span></span><br><span class="line">    <span class="built_in">int</span> BulletNumber &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等同于声明这两个抽象方法：</span></span><br><span class="line">    <span class="comment">// int get_BulletNumber();</span></span><br><span class="line">    <span class="comment">// void set_BulletNumber(int value);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现类必须提供完整实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Pistol</span> : <span class="title">IWeapon</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 方式一：自动属性（编译器自动生成后备字段和实现）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> BulletNumber &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方式二：完整属性（手动定义后备字段和逻辑）</span></span><br><span class="line">    <span class="comment">// private int _bulletNumber;</span></span><br><span class="line">    <span class="comment">// public int BulletNumber </span></span><br><span class="line">    <span class="comment">// &#123; </span></span><br><span class="line">    <span class="comment">//     get &#123; return _bulletNumber; &#125;</span></span><br><span class="line">    <span class="comment">//     set &#123; _bulletNumber = value; &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键点</strong>：</p><ul><li>接口中的 <code>&#123; get; set; &#125;</code> 是<strong>抽象声明</strong>，强制实现类提供实现和数据存储</li><li>类中的 <code>&#123; get; set; &#125;</code> 是<strong>自动属性</strong>，编译器自动生成后备字段和完整实现</li></ul><h3 id="接口默认实现（C-8-0-）"><a href="#接口默认实现（C-8-0-）" class="headerlink" title="接口默认实现（C# 8.0+）"></a>接口默认实现（C# 8.0+）</h3><p>从 C# 8.0 开始，接口可以包含<strong>默认实现</strong>，主要用于 API 的版本演进。</p><p><strong>引入原因</strong>：解决接口扩展时的破坏性更改问题。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 场景：为已有接口添加新功能，但不破坏现有实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IWeapon</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Attack</span>()</span>;  <span class="comment">// 原有方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// C# 8.0+：为新方法提供默认实现</span></span><br><span class="line">    <span class="comment">// 现有实现类无需修改，新类可以选择重写</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Reload</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Default reload behavior&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>属性的默认实现示例</strong>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IWeapon</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 抽象属性：必须由实现类提供（用于存储状态）</span></span><br><span class="line">    <span class="built_in">int</span> CurrentAmmo &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="built_in">int</span> MaxAmmo &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 默认实现的计算属性：基于其他抽象成员</span></span><br><span class="line">    <span class="built_in">bool</span> IsEmpty</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> CurrentAmmo &lt;= <span class="number">0</span>; &#125;  <span class="comment">// ✅ 正确：依赖抽象属性</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 默认实现的方法：操作抽象成员</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Shoot</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!IsEmpty)</span><br><span class="line">        &#123;</span><br><span class="line">            CurrentAmmo--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="⚠️-常见错误：接口默认实现的递归陷阱"><a href="#⚠️-常见错误：接口默认实现的递归陷阱" class="headerlink" title="⚠️ 常见错误：接口默认实现的递归陷阱"></a>⚠️ 常见错误：接口默认实现的递归陷阱</h3><p><strong>错误示例</strong>（会导致 <code>StackOverflowException</code>）：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IWeapon</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ❌ 错误：接口不能包含实例字段（后备字段）</span></span><br><span class="line">    <span class="built_in">int</span> bulletNumber </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 无限递归！调用 get 来获取 bulletNumber，而 bulletNumber 又调用 get...</span></span><br><span class="line">            <span class="keyword">return</span> bulletNumber;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 无限递归！调用 set 来设置 bulletNumber，而 bulletNumber 又调用 set...</span></span><br><span class="line">            bulletNumber = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>原因</strong>：接口不能包含实例状态（字段）。上述代码中没有后备字段来存储数据，访问属性会无限递归调用自身。</p><p><strong>正确的做法</strong>：</p><ul><li><strong>抽象声明</strong>：让实现类提供存储</li><li><strong>默认实现</strong>：基于其他抽象成员进行计算或逻辑处理</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;创建属性&quot;&gt;&lt;a href=&quot;#创建属性&quot; class=&quot;headerlink&quot; title=&quot;创建属性&quot;&gt;&lt;/a&gt;创建属性&lt;/h1&gt;&lt;p&gt;属性本质上是对变量的 get 和 set 访问器的封装。&lt;/p&gt;
&lt;p&gt;对于需要公开访问的字段，直接使用 public 修饰</summary>
      
    
    
    
    <category term="C#" scheme="https://siyuewei.github.io/categories/C/"/>
    
    
    <category term="C#" scheme="https://siyuewei.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>WASM</title>
    <link href="https://siyuewei.github.io/2025/10/29/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/WASM/"/>
    <id>https://siyuewei.github.io/2025/10/29/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/WASM/</id>
    <published>2025-10-29T10:21:34.000Z</published>
    <updated>2025-10-29T10:27:58.049Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>WASM (WebAssembly) 是一种“网页汇编”技术。</p><p>是一种低级 (low-level) 的、高性能的“二进制指令格式”，专门设计用于在网页浏览器中运行。对标exe。</p><p>可以理解为一种让 C++、C#、Rust、Go 等高性能语言编写的代码，能够以接近原生的速度在浏览器里运行的方式。</p><h1 id="出现原因"><a href="#出现原因" class="headerlink" title="出现原因"></a>出现原因</h1><p>JavaScript 是唯一能在浏览器中运行的编程语言。</p><p>JavaScript 是一种很棒的脚本语言，但它在执行非常繁重的计算任务时（比如 3D 游戏引擎、视频编辑、物理模拟、图像识别）会非常吃力，速度跟不上。</p><p>开发者们渴望能用 C++ 或 Rust 这种高性能语言来编写程序，因为它们运行速度极快。</p><p>但 C++ 编译出来的程序是 .exe (Windows) 或 .app (Mac)，它们无法在浏览器这个“沙盒”里运行。</p><p>WASM就是用来做这种翻译的，工作流如下：</p><ul><li>编写 (开发者)：开发者使用 C++ 或 Rust 编写了一个高性能的程序（例如一个 3D 游戏的物理引擎）。</li><li>编译 (工具链)：开发者使用一个特殊的编译器（如 Emscripten），不把 C++ 代码编译成 .exe。而是把它编译成一种平台无关的、高度优化的二进制文件，扩展名为 .wasm。</li><li>运行 (浏览器)：浏览器（如 Chrome, Firefox）加载这个 .wasm 文件。浏览器内部的 JavaScript 引擎（它也是一个虚拟机）能极快地解析和执行这种二进制格式，速度远超解析 JavaScript 文本。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;p&gt;WASM (WebAssembly) 是一种“网页汇编”技术。&lt;/p&gt;
&lt;p&gt;是一种低级 (low-level) 的、高性能的“二进制指令格</summary>
      
    
    
    
    <category term="Basic Concept" scheme="https://siyuewei.github.io/categories/Basic-Concept/"/>
    
    
    <category term="Rendering" scheme="https://siyuewei.github.io/tags/Rendering/"/>
    
    <category term="Basic Concept" scheme="https://siyuewei.github.io/tags/Basic-Concept/"/>
    
    <category term="WASM" scheme="https://siyuewei.github.io/tags/WASM/"/>
    
  </entry>
  
  <entry>
    <title>GPGPU概念与实现</title>
    <link href="https://siyuewei.github.io/2025/10/29/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/GPGPU%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>https://siyuewei.github.io/2025/10/29/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/GPGPU%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%AE%9E%E7%8E%B0/</id>
    <published>2025-10-29T08:57:00.000Z</published>
    <updated>2025-10-29T10:04:06.969Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Computer-Shader"><a href="#Computer-Shader" class="headerlink" title="Computer Shader"></a>Computer Shader</h1><h2 id="概念区分"><a href="#概念区分" class="headerlink" title="概念区分"></a>概念区分</h2><p>GPGPU (General-Purpose computing on Graphics Processing Units)：这是一个概念或领域。它指的是“使用 GPU 强大的并行处理能力来执行传统上由 CPU 负责的通用计算任务”（如图形渲染之外的科学计算、物理模拟、AI 训练等）。</p><p>Compute Shader (计算着色器)：这是一种具体的技术实现。它是一种程序（ HLSL, GLSL, MSL 等语言编写），它允许开发者在 GPU 上执行通用的计算。它最大的特点是它独立于传统的“渲染管线”（即独立于顶点着色器和片段着色器）。</p><h2 id="为什么说“它独立于传统的渲染管线”"><a href="#为什么说“它独立于传统的渲染管线”" class="headerlink" title="为什么说“它独立于传统的渲染管线”"></a>为什么说“它独立于传统的渲染管线”</h2><p>Computer Shader与VS，FS都叫“着色器”(Shader)，都使用 HLSL 或 GLSL 这样的语言编写，并且都运行在 GPU 内部完全相同的“统一着色器核心”上。</p><p>而“独立于顶点着色器和片段着色器”是在说：传统的渲染管线工序严格定义为顶点处理(VS) -&gt; 光栅化 -&gt; 像素处理(FS) -&gt; 输出图像，但是Computer Shader并不直接在这条管线里面工作，不关心什么顶点和像素，它的输入可以是任何数据，输出也可以是任何数据。在应用上，它的逻辑其实就类似在GPU上运行的代码，只不过是这一块代码是在GPU上运行的，并且由GPU统一管控。</p><h2 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h2><p>举个例子，让一张 100 万像素的图片全部变亮。</p><p>CPU 逻辑：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 1000000; ++i) &#123;</span><br><span class="line">    pixels[i] = pixels[i] * 1.1; // 串行执行 100 万次</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GPGPU 逻辑 (伪代码)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 只写这个函数，它只处理一个像素</span><br><span class="line">void BrightenKernel(int i) &#123;</span><br><span class="line">    pixels[i] = pixels[i] * 1.1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// (在 CPU 端) 调用：</span><br><span class="line">// “GPU，请在 100 万个核心上同时运行 BrightenKernel 函数”</span><br><span class="line">Dispatch(1000000);</span><br></pre></td></tr></table></figure><h2 id="Compute-Shader如何助力渲染过程"><a href="#Compute-Shader如何助力渲染过程" class="headerlink" title="Compute Shader如何助力渲染过程"></a>Compute Shader如何助力渲染过程</h2><p>Compute Shader助力渲染过程不是直接插入渲染管线，而是使用多步骤，也即Pass。</p><p>第一步，先运行一个 Compute Pass，让 Compute Shader 这个“通用车间”去完成所有繁重的计算（比如模拟成千上万个粒子的运动位置），并把计算结果存放到一块“仓库”（如 Buffer 或 Texture）里。</p><p>第二步，再运行一个 Render Pass，启动那条“渲染管线”，此时你的 VS 和 FS 程序不再需要自己去苦苦计算，它们可以直接去“仓库”里读取 Compute Shader 算好的现成数据，然后轻松地把它们画在屏幕上。</p><h1 id="SSBO"><a href="#SSBO" class="headerlink" title="SSBO"></a>SSBO</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>SSBO (Shader Storage Buffer Object，着色器存储缓冲对象) 是一种在 GPU 上分配的<strong>通用内存缓冲区</strong>。</p><p>你可以把它想象成一块“大容量、可读写的 GPU 内存”，所有类型的着色器（尤其是 Compute Shader）都可以自由地从中读取和写入数据。</p><p>SSBO 是现代图形 API (如 OpenGL 4.3+, Vulkan, Metal, WebGPU) 中的一个核心功能，它的出现<strong>是 GPGPU 和 Compute Shader 得以普及的关键基石</strong>。</p><hr><h2 id="SSBO-的核心特性"><a href="#SSBO-的核心特性" class="headerlink" title="SSBO 的核心特性"></a>SSBO 的核心特性</h2><ol><li><p><strong>读写能力 (Read&#x2F;Write Access)</strong></p><ul><li>这是 SSBO <strong>最重要</strong>的特性。在 SSBO 出现之前，GPU 上的大多数数据缓冲区（比如 UBO）对 Shader 来说都是“只读”的。</li><li>有了 SSBO，你的 Compute Shader <strong>不仅可以读取数据，还可以把计算结果写回去</strong>。</li><li>它甚至支持<strong>原子操作</strong>（Atomics），这允许多个 GPU 线程同时读写同一块内存区域而不会导致数据错乱，这对于并行计数、构建列表等高级算法至关重要。</li></ul></li><li><p><strong>超大容量 (Very Large Size)</strong></p><ul><li>在 SSBO 之前，我们有 <strong>UBO (Uniform Buffer Object)</strong>，它用于向 Shader 传递常量（比如摄像机矩阵）。但 UBO 的容量<strong>非常小</strong>（例如，通常限制在 64KB）。</li><li>SSBO 的容量限制<strong>非常大</strong>，通常只受限于你显卡的<strong>总显存大小</strong>（可能是几百 MB 甚至几个 GB）。</li></ul></li><li><p><strong>灵活的结构 (Flexible Structure)</strong></p><ul><li>SSBO 就是一块原始内存。你可以在其中定义<strong>任意的数据结构</strong>，最常见的就是定义一个 <code>struct</code>（结构体），然后创建一个由这个结构体组成的<strong>巨大数组</strong>。</li></ul></li><li><p><strong>通用性 (General Purpose)</strong></p><ul><li>SSBO 不仅可以被 <strong>Compute Shader</strong> 访问，也可以在<strong>顶点着色器 (VS)</strong> 和<strong>片段着色器 (FS)</strong> 中访问。这使得在不同管线阶段共享海量数据成为可能。</li></ul></li></ol><hr><h2 id="为什么-SSBO-如此重要？"><a href="#为什么-SSBO-如此重要？" class="headerlink" title="为什么 SSBO 如此重要？"></a>为什么 SSBO 如此重要？</h2><p><strong>一句话：没有 SSBO，Compute Shader 就几乎毫无用处。</strong></p><p>Compute Shader (GPGPU) 的目标是处理大规模并行计算。这些计算需要满足两个条件：</p><ol><li>需要<strong>输入</strong>海量数据。</li><li>需要<strong>输出</strong>海量数据。</li></ol><p>UBO 太小了，根本无法承载这些数据。而 SSBO 完美地解决了这两个问题。</p><hr><h2 id="一个生动的例子：100-万个粒子的物理模拟"><a href="#一个生动的例子：100-万个粒子的物理模拟" class="headerlink" title="一个生动的例子：100 万个粒子的物理模拟"></a>一个生动的例子：100 万个粒子的物理模拟</h2><p>假设你想在 GPU 上模拟 100 万个粒子的运动。</p><ul><li><p><strong>数据：</strong> 你需要存储每个粒子的 <code>位置 (vec3)</code>、<code>速度 (vec3)</code>、<code>生命周期 (float)</code> 等。这 100 万个粒子的数据量会非常大（例如 <code>(12+12+4) * 1,000,000 = 28MB</code>），UBO 根本放不下。</p></li><li><p><strong>SSBO 的解决方案：</strong></p><ol><li><strong>创建 (CPU端)：</strong> 在 CPU 上创建一个 SSBO，其大小足以容纳 100 万个 <code>Particle</code> 结构体。</li><li><strong>计算 (GPU - Compute Pass)：</strong><ul><li>启动一个 <strong>Compute Shader</strong>，并让 GPU 开启 100 万个线程。</li><li><strong>绑定 SSBO</strong>，让 Compute Shader 可以<strong>读写</strong>它。</li><li><strong>每个线程</strong>负责<strong>读取</strong>一个粒子的当前位置和速度，计算它下一帧的新位置和新速度，然后<strong>写回</strong> SSBO 中<strong>同一个粒子</strong>的数据。</li></ul></li><li><strong>渲染 (GPU - Render Pass)：</strong><ul><li>启动<strong>渲染管线</strong> (VS + FS)。</li><li><strong>绑定同一个 SSBO</strong>（这次是作为只读）。</li><li><strong>顶点着色器 (VS)</strong> 也启动 100 万次，它从 SSBO 中<strong>读取</strong>每个粒子的（已被 Compute Shader 更新过的）位置，然后把它们画在屏幕上。</li></ul></li></ol></li></ul><hr><h2 id="总结对比：SSBO-vs-UBO"><a href="#总结对比：SSBO-vs-UBO" class="headerlink" title="总结对比：SSBO vs. UBO"></a>总结对比：SSBO vs. UBO</h2><p>为了帮你更好地区分，这里有一个表格：</p><table><thead><tr><th align="left">特性</th><th align="left"><strong>SSBO (Shader Storage Buffer Object)</strong></th><th align="left"><strong>UBO (Uniform Buffer Object)</strong></th></tr></thead><tbody><tr><td align="left"><strong>主要用途</strong></td><td align="left"><strong>通用计算存储 (GPGPU)</strong>、海量数据</td><td align="left"><strong>常量数据</strong> (如变换矩阵、灯光设置)</td></tr><tr><td align="left"><strong>Shader 访问</strong></td><td align="left"><strong>可读 &#x2F; 可写</strong> (Read&#x2F;Write)</td><td align="left"><strong>只读</strong> (Read-Only)</td></tr><tr><td align="left"><strong>大小限制</strong></td><td align="left"><strong>非常大</strong> (GB 级别，受显存限制)</td><td align="left"><strong>非常小</strong> (KB 级别，如 64KB)</td></tr><tr><td align="left"><strong>主要搭档</strong></td><td align="left"><strong>Compute Shader</strong></td><td align="left">Vertex Shader, Fragment Shader</td></tr></tbody></table><p><strong>一句话总结：</strong></p><ul><li><strong>UBO</strong> 是 GPU 的一块“<strong>只读小黑板</strong>”，用于告诉所有线程“今天的规则是什么”（比如摄像机在哪）。</li><li><strong>SSBO</strong> 是 GPU 的一个“<strong>巨大共享仓库</strong>”，所有线程都可以进去拿货（读取）和放货（写入），是 GPGPU 的核心数据中枢。</li></ul><h1 id="Indirect-Draw"><a href="#Indirect-Draw" class="headerlink" title="Indirect Draw"></a>Indirect Draw</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>Indirect Draw指绘制数据不再由CPU告诉GPU，而是GPU自己去读SSBO，获取绘制数据。CPU要做的事情只是发送一条指令，告诉GPU去哪里读取数据，并进行绘制。</p><p>同时，Indirect Draw也有一个对应的API，vkCmdDrawIndirect，是GPU用来给CPU发消息的。</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="直接绘制-Direct-Draw"><a href="#直接绘制-Direct-Draw" class="headerlink" title="直接绘制 (Direct Draw)"></a>直接绘制 (Direct Draw)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// CPU 必须在“调用时”就明确知道要画多少个顶点</span><br><span class="line">int vertexCount = 6000;</span><br><span class="line">int instanceCount = 1000;</span><br><span class="line">int firstVertex = 0;</span><br><span class="line">int firstInstance = 0;</span><br><span class="line"></span><br><span class="line">// CPU 将这些“参数”直接打包成命令</span><br><span class="line">// &quot;画 6000 个顶点, 1000 个实例, ...&quot;</span><br><span class="line">vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance);</span><br></pre></td></tr></table></figure><h3 id="间接绘制（Indirect-Draw）"><a href="#间接绘制（Indirect-Draw）" class="headerlink" title="间接绘制（Indirect Draw）"></a>间接绘制（Indirect Draw）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// CPU 不知道要画多少个。它只知道“绘制参数”被存在了哪个 GPU 缓冲区里。</span><br><span class="line">VkBuffer drawArgumentsBuffer = ...; // 这是一个 SSBO</span><br><span class="line">uint32_t bufferOffset = 0;</span><br><span class="line"></span><br><span class="line">// CPU 发送一个“间接”命令</span><br><span class="line">// &quot;去 drawArgumentsBuffer 的 0 偏移处，自己读取参数，然后按那个参数画&quot;</span><br><span class="line">vkCmdDrawIndirect(commandBuffer, drawArgumentsBuffer, bufferOffset, 1, ...);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Computer-Shader&quot;&gt;&lt;a href=&quot;#Computer-Shader&quot; class=&quot;headerlink&quot; title=&quot;Computer Shader&quot;&gt;&lt;/a&gt;Computer Shader&lt;/h1&gt;&lt;h2 id=&quot;概念区分&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="Basic Concept" scheme="https://siyuewei.github.io/categories/Basic-Concept/"/>
    
    
    <category term="Rendering" scheme="https://siyuewei.github.io/tags/Rendering/"/>
    
    <category term="Basic Concept" scheme="https://siyuewei.github.io/tags/Basic-Concept/"/>
    
    <category term="Computer Shader" scheme="https://siyuewei.github.io/tags/Computer-Shader/"/>
    
    <category term="BBSO" scheme="https://siyuewei.github.io/tags/BBSO/"/>
    
  </entry>
  
  <entry>
    <title>Unite_小游戏开发</title>
    <link href="https://siyuewei.github.io/2025/10/29/Rendering/Unite-%E5%B0%8F%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    <id>https://siyuewei.github.io/2025/10/29/Rendering/Unite-%E5%B0%8F%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/</id>
    <published>2025-10-29T08:16:51.000Z</published>
    <updated>2025-11-16T07:53:53.023Z</updated>
    
    <content type="html"><![CDATA[<h1 id="移动平台的图形引擎"><a href="#移动平台的图形引擎" class="headerlink" title="移动平台的图形引擎"></a>移动平台的图形引擎</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>WebGL和 WebGPU 是用于网页浏览器的图形 API，Metal 和 Vulkan 是用于操作系统和硬件的“原生” (Native) 图形 API。</p><p>WebGL 和WebGPU是网页渲染的写法，但是真实渲染到电脑上，需要用电脑的渲染API，所以要翻译。而翻译这件事是浏览器在做的。</p><p><img src="/../../Image/Unite-%E5%B0%8F%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Metal%20vs%20WebcL&WebGPu.jpg" alt="Metal与WebGL&#x2F;WebGPU的对比"></p><h2 id="WebGL"><a href="#WebGL" class="headerlink" title="WebGL"></a>WebGL</h2><ul><li><p><strong>定义</strong>：JavaScript API，用于在浏览器中渲染 2D 和 3D 图形，无需任何插件。</p></li><li><p><strong>版本历史</strong>：</p><ul><li>WebGL 1.0 基于 OpenGL ES 2.0</li><li>WebGL 2.0（目前主流）基于 OpenGL ES 3.0（2012年发布）</li></ul></li><li><p><strong>现状</strong>：已经过时，WebGL不会再有任何Major Feature Update。</p></li><li><p><strong>主要限制</strong>：缺失现代图形API的常用特性：Compute Shader，SSBO，Indirect Draw</p></li></ul><h2 id="WebGPU"><a href="#WebGPU" class="headerlink" title="WebGPU"></a>WebGPU</h2><p>W3C 正在制定的下一代网页图形 API，被视为 WebGL 的继任者。</p><ul><li><p>浏览器环境，着重跨平台</p></li><li><p>无原生驱动，和WebGL一样需要转译</p></li><li><p>仍在完善中</p></li></ul><h2 id="Metal"><a href="#Metal" class="headerlink" title="Metal"></a>Metal</h2><ul><li><p>苹果的专属图形API接口，从iOS13起成为”唯一”官方支持的图形接口</p></li><li><p>可使用Apple芯片专属图形特征</p></li></ul><h3 id="小游戏Metal解决方案"><a href="#小游戏Metal解决方案" class="headerlink" title="小游戏Metal解决方案"></a>小游戏Metal解决方案</h3><p><img src="/../../Image/Unite-%E5%B0%8F%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E5%B0%8F%E6%B8%B8%E6%88%8FMetal%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.jpg" alt="小游戏Metal解决方案"></p><p><img src="/../../Image/Unite-%E5%B0%8F%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E5%B0%8F%E6%B8%B8%E6%88%8FMetal%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%882.jpg" alt="小游戏Metal解决方案"></p><p>游戏逻辑在 WASM 中高速运行，把渲染指令”打包”成数据，通过 XHR 发送给原生 App，原生 App 再”解包”并调用真正的 Metal API 去画图。 这完全绕过了 WebKit 的 WebGL 渲染管线。</p><h4 id="1-顶层：WebKit-进程-WASM"><a href="#1-顶层：WebKit-进程-WASM" class="headerlink" title="1. 顶层：WebKit 进程 (WASM)"></a>1. 顶层：WebKit 进程 (WASM)</h4><ul><li><p>游戏逻辑（很可能是C++或Rust写的）被编译成了 WASM (WebAssembly)，以高性能运行在 WebKit 进程中。</p></li><li><p>游戏”以为”自己在调用 Metal API。但实际上，它调用的是一个”假的” Metal 接口。</p></li><li><p><strong>编码层：</strong> 这个”假接口”不执行任何渲染，而是把所有的 Metal 调用（比如”设置这个纹理”、”画 500 个三角形”）编码 (Encode) 成一个自定义的”指令流”（一长串二进制数据）。</p></li></ul><h4 id="2-中间层：跨进程通信-XHR"><a href="#2-中间层：跨进程通信-XHR" class="headerlink" title="2. 中间层：跨进程通信 (XHR)"></a>2. 中间层：跨进程通信 (XHR)</h4><ul><li><p>在 WASM 里生成的”指令流”需要被发送出去。</p></li><li><p>使用了 XMLHttpRequest (XHR)——这个通常用于网页请求网络数据的工具——来作为跨进程通信 (IPC) 的桥梁。</p></li><li><p><strong>流程：</strong> WASM 把编码好的指令流数据，通过 XHR “发送”给”宿主进程”。</p></li></ul><h4 id="3-底层：宿主进程-Native-Metal"><a href="#3-底层：宿主进程-Native-Metal" class="headerlink" title="3. 底层：宿主进程 (Native Metal)"></a>3. 底层：宿主进程 (Native Metal)</h4><ul><li><p>“宿主”指的是包着这个 WebKit 的原生 App（比如微信、抖音等）。</p></li><li><p>宿主进程接收到这个 XHR 请求（实际上是来自内部的数据）。</p></li><li><p><strong>解码与提交：</strong> 宿主进程的原生代码（Objective-C &#x2F; Swift）解码这个”指令流”，并将其”翻译”回真正的 Metal API 指令，然后提交给 GPU 去执行。</p></li></ul><p><img src="/../../Image/Unite-%E5%B0%8F%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Metal%E5%B0%8F%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91Challenges.jpg" alt="Metal小游戏开发Challenges"></p><h3 id="Shared-Buffer"><a href="#Shared-Buffer" class="headerlink" title="Shared Buffer"></a>Shared Buffer</h3><p>在 iPhone 和 iPad 上，CPU 和 GPU 共享同一块物理内存 (RAM)。</p><p>上传数据： CPU 往这块内存里写入数据（比如更新粒子位置），然后通知 GPU：“你可以去读了”。GPU 不需要“拷贝”，直接就能读到 CPU 刚写的数据。</p><p>GPU 回读： Compute Shader 把计算结果写回这块内存，然后通知 CPU：“我写完了”。CPU 不需要“下载”，直接就能读到 GPU 刚算出的结果。</p><p>需要写入数据的游戏逻辑 (WASM) 运行在 WebKit 进程 (进程1) 中</p><h3 id="为什么“XHR-指令流方案”做不到"><a href="#为什么“XHR-指令流方案”做不到" class="headerlink" title="为什么“XHR 指令流方案”做不到"></a>为什么“XHR 指令流方案”做不到</h3><p>这个方案横跨了两个独立的进程，这两个进程都运行在手机端，但是存在数据隔离：</p><ul><li><p>WebKit 进程： 运行游戏逻辑 (WASM)。</p></li><li><p>宿主进程： 运行原生 App 代码，调用真正的 Metal。</p></li></ul><p>那块“真正的 Metal Shared Buffer” 是由宿主进程 (进程2) 创建和拥有的。而需要写入数据的游戏逻辑 (WASM) 运行在 WebKit 进程 (进程1) 中。<br>由于“内存隔离”，WASM 不可能拿到那块 Shared Buffer 的内存地址。因此，数据必须被“拷贝”：</p><ul><li><p>上传 (WASM -&gt; Metal)： WASM 必须把它的数据（比如顶点数组）打包并拷贝到 XHR 请求体中。</p></li><li><p>宿主进程收到 XHR 请求，再从请求体中拷贝出数据。</p></li><li><p>宿主进程再把这些数据拷贝到真正的 Metal Buffer 中。</p></li></ul><p>这里发生了至少两次数据拷贝，而不是零拷贝）。</p><ul><li>回读 (Metal -&gt; WASM)： 流程反过来，同样需要多次拷贝。</li></ul><h2 id="Vulkan"><a href="#Vulkan" class="headerlink" title="Vulkan"></a>Vulkan</h2><ul><li><p>OpenGL(ES)的后继者</p></li><li><p>对GPU最底层、最精确的控制</p></li><li><p>逐渐成为重度渲染的移动端游戏的首选</p></li><li><p>驱动仍在完善，需要手动调优</p></li></ul><p><img src="/../../Image/Unite-%E5%B0%8F%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E5%B0%8F%E6%B8%B8%E6%88%8FVulkan%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.jpg" alt="小游戏Vulkan解决方案"></p><h3 id="双线程思路"><a href="#双线程思路" class="headerlink" title="双线程思路"></a>双线程思路</h3><p>使用两个线程，而非两个进程，这样两个线程之间的数据是共享的。</p><ul><li>Main Thread (主线程)：负责处理所有与用户交互的事情，比如点击屏幕、UI 动画、游戏的主要逻辑更新等</li><li>Worker Thread (工作线程)：唯一工作就是处理所有繁重的渲染任务，准备 Vulkan 指令、调用 Native 函数、与 GPU 通信。</li></ul><h3 id="关键技术：SharedArrayBuffer-Atomics"><a href="#关键技术：SharedArrayBuffer-Atomics" class="headerlink" title="关键技术：SharedArrayBuffer + Atomics"></a>关键技术：SharedArrayBuffer + Atomics</h3><p>SharedArrayBuffer (SAB)：这是现代 Web API 的一个特性。允许 Main Thread 和 Worker Thread 创建一块它们都能读写的“共享内存区域”。</p><p>Atomics：这是一组用于“同步”的指令。当 Worker 正在写入这块内存时，Atomics 可以确保主线程不会同时去读取它，反之亦然，保证了数据安全。</p><h3 id="WASM-直接调用-Native"><a href="#WASM-直接调用-Native" class="headerlink" title="WASM 直接调用 Native"></a>WASM 直接调用 Native</h3><p>如图所示，所有的渲染运行在 Worker Thread 中。</p><p>宿主 App（比如微信）会把“真实的 Vulkan 函数”（用 C++ 编写的）“注入” 到这个 Worker 线程中。这意味着 WASM 可以直接 import 并调用这些“原生 (Native) Vulkan 函数”。</p><h3 id="结果：零拷贝-Zero-Copy"><a href="#结果：零拷贝-Zero-Copy" class="headerlink" title="结果：零拷贝 (Zero-Copy)"></a>结果：零拷贝 (Zero-Copy)</h3><ol><li><p>Main Thread 准备好渲染数据（比如场景信息）。</p></li><li><p>Main Thread 把数据写入到 SharedArrayBuffer 中。</p></li><li><p>Worker Thread 里的 WASM 直接从这块 SharedArrayBuffer（也就是它的 WASM Heap）中读取数据，并组装成 Vulkan 需要的 Descriptor (渲染指令)。</p></li><li><p>WASM 调用那个被“注入”的 Native Vulkan 函数。</p></li><li><p>Native 函数也直接从那块 SharedArrayBuffer 中读取 WASM 组装好的指令，然后提交给 GPU。</p></li></ol><p>数据从始至终都在同一块共享内存里，没有发生任何“拷贝”。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;移动平台的图形引擎&quot;&gt;&lt;a href=&quot;#移动平台的图形引擎&quot; class=&quot;headerlink&quot; title=&quot;移动平台的图形引擎&quot;&gt;&lt;/a&gt;移动平台的图形引擎&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="Rendering" scheme="https://siyuewei.github.io/categories/Rendering/"/>
    
    
    <category term="Rendering" scheme="https://siyuewei.github.io/tags/Rendering/"/>
    
    <category term="Basic Concept" scheme="https://siyuewei.github.io/tags/Basic-Concept/"/>
    
  </entry>
  
  <entry>
    <title>SSHLink</title>
    <link href="https://siyuewei.github.io/2025/10/24/Tools/SSHLink/"/>
    <id>https://siyuewei.github.io/2025/10/24/Tools/SSHLink/</id>
    <published>2025-10-24T07:49:27.000Z</published>
    <updated>2025-10-28T15:57:08.818Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SSH-Link"><a href="#SSH-Link" class="headerlink" title="SSH Link"></a>SSH Link</h1><p>在用vscode连接远端服务器，账号之前删除过，现在重现创建后连不上了。很可能是以前连的本地密钥没删，重装后连不上了。</p><p>当你用 VS Code (或其他任何 SSH 客户端) 连接服务器时，主要涉及两个地方的”信任”：</p><ul><li><p>服务器信任你（你的电脑）：通过authorized_keys文件。</p></li><li><p>你（你的电脑）信任服务器：通过known_hosts文件。</p></li></ul><p>情况一：一般报错Permission denied (publickey)，需要在服务器上重新添加自己的公钥</p><p>情况二：一般报错REMOTE HOST IDENTIFICATION HAS CHANGED 或 OFFENDING_KEY_IN_KNOWN_HOSTS，需要修改自己本地的~&#x2F;.ssh&#x2F;known_hosts 文件</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SSH-Link&quot;&gt;&lt;a href=&quot;#SSH-Link&quot; class=&quot;headerlink&quot; title=&quot;SSH Link&quot;&gt;&lt;/a&gt;SSH Link&lt;/h1&gt;&lt;p&gt;在用vscode连接远端服务器，账号之前删除过，现在重现创建后连不上了。很可能是以前连的本地</summary>
      
    
    
    
    
    <category term="Tips" scheme="https://siyuewei.github.io/tags/Tips/"/>
    
  </entry>
  
  <entry>
    <title>C#反射</title>
    <link href="https://siyuewei.github.io/2025/10/18/C#/C#%E5%8F%8D%E5%B0%84/"/>
    <id>https://siyuewei.github.io/2025/10/18/C#/C#%E5%8F%8D%E5%B0%84/</id>
    <published>2025-10-18T15:05:12.000Z</published>
    <updated>2025-10-30T10:47:24.724Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-反射"><a href="#C-反射" class="headerlink" title="C#反射"></a>C#反射</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>反射（Reflection）是C#中一种强大的机制，它允许程序在运行时检查和操作类型的元数据信息。通过反射，可以在运行时动态地获取类型信息、创建对象实例、调用方法、访问属性和字段等。</p><p>反射的核心是<code>System.Reflection</code>命名空间，其中<code>Type</code>类是反射的基础。</p><h2 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h2><p>本质就是可以通过<code>Type</code>，在程序运行时去动态获取当前类里面的信息。运行前可能不知道类的具体信息，运行中可以直接获取。</p><h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><p>反射可以实现以下功能：</p><ol><li><strong>获取类型信息</strong>：获取类、接口、结构体等的元数据</li><li><strong>动态创建对象</strong>：在运行时创建类型的实例</li><li><strong>动态调用方法</strong>：在运行时调用对象的方法</li><li><strong>访问成员</strong>：读取或设置字段、属性的值</li><li><strong>查看特性（Attribute）</strong>：获取类型上标注的特性信息</li><li><strong>遍历程序集</strong>：查看程序集中包含的所有类型</li></ol><h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><h3 id="获取Type对象的方式"><a href="#获取Type对象的方式" class="headerlink" title="获取Type对象的方式"></a>获取Type对象的方式</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 使用 typeof 关键字</span></span><br><span class="line">Type type1 = <span class="keyword">typeof</span>(MyClass);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 使用 GetType() 方法</span></span><br><span class="line">MyClass obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">Type type2 = obj.GetType();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 使用 Type.GetType() 方法</span></span><br><span class="line">Type type3 = Type.GetType(<span class="string">&quot;命名空间.MyClass&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="常用反射方法"><a href="#常用反射方法" class="headerlink" title="常用反射方法"></a>常用反射方法</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所有公共方法</span></span><br><span class="line">MethodInfo[] methods = type.GetMethods();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有公共属性</span></span><br><span class="line">PropertyInfo[] properties = type.GetProperties();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有公共字段</span></span><br><span class="line">FieldInfo[] fields = type.GetFields();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有构造函数</span></span><br><span class="line">ConstructorInfo[] constructors = type.GetConstructors();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="built_in">object</span> instance = Activator.CreateInstance(type);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方法</span></span><br><span class="line">MethodInfo method = type.GetMethod(<span class="string">&quot;MethodName&quot;</span>);</span><br><span class="line">method.Invoke(instance, <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; param1, param2 &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取/设置属性值</span></span><br><span class="line">PropertyInfo property = type.GetProperty(<span class="string">&quot;PropertyName&quot;</span>);</span><br><span class="line"><span class="built_in">object</span> <span class="keyword">value</span> = property.GetValue(instance);</span><br><span class="line">property.SetValue(instance, newValue);</span><br></pre></td></tr></table></figure><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li><strong>插件系统</strong>：动态加载和使用外部程序集中的类型</li><li><strong>依赖注入（DI）容器</strong>：如ASP.NET Core的依赖注入框架</li><li><strong>序列化&#x2F;反序列化</strong>：JSON、XML等序列化库</li><li><strong>ORM框架</strong>：如Entity Framework，动态映射对象和数据库</li><li><strong>单元测试框架</strong>：如NUnit、xUnit，动态发现和执行测试方法</li><li><strong>自动化工具</strong>：根据配置文件动态创建和调用对象</li><li><strong>代码生成工具</strong>：分析现有类型生成代码</li><li><strong>特性处理</strong>：处理自定义特性标记的类和方法</li></ol><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SayHello</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;你好，我是<span class="subst">&#123;Name&#125;</span>，<span class="subst">&#123;Age&#125;</span>岁。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetInfo</span>(<span class="params"><span class="built_in">string</span> prefix</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">$&quot;<span class="subst">&#123;prefix&#125;</span>: <span class="subst">&#123;Name&#125;</span>, <span class="subst">&#123;Age&#125;</span>岁&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取Type对象</span></span><br><span class="line">        Type type = <span class="keyword">typeof</span>(Person);</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;类型名称: <span class="subst">&#123;type.Name&#125;</span>&quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;完整名称: <span class="subst">&#123;type.FullName&#125;</span>&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建实例</span></span><br><span class="line">        <span class="built_in">object</span> personObj = Activator.CreateInstance(type);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置属性值</span></span><br><span class="line">        PropertyInfo nameProp = type.GetProperty(<span class="string">&quot;Name&quot;</span>);</span><br><span class="line">        PropertyInfo ageProp = type.GetProperty(<span class="string">&quot;Age&quot;</span>);</span><br><span class="line">        nameProp.SetValue(personObj, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        ageProp.SetValue(personObj, <span class="number">25</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取属性值</span></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;姓名: <span class="subst">&#123;nameProp.GetValue(personObj)&#125;</span>&quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;年龄: <span class="subst">&#123;ageProp.GetValue(personObj)&#125;</span>&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用无参方法</span></span><br><span class="line">        MethodInfo sayHelloMethod = type.GetMethod(<span class="string">&quot;SayHello&quot;</span>);</span><br><span class="line">        sayHelloMethod.Invoke(personObj, <span class="literal">null</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用有参方法</span></span><br><span class="line">        MethodInfo getInfoMethod = type.GetMethod(<span class="string">&quot;GetInfo&quot;</span>);</span><br><span class="line">        <span class="built_in">object</span> result = getInfoMethod.Invoke(personObj, <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; <span class="string">&quot;个人信息&quot;</span> &#125;);</span><br><span class="line">        Console.WriteLine(result);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 列出所有公共属性</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;\n所有公共属性:&quot;</span>);</span><br><span class="line">        <span class="keyword">foreach</span> (PropertyInfo prop <span class="keyword">in</span> type.GetProperties())</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;- <span class="subst">&#123;prop.Name&#125;</span> (<span class="subst">&#123;prop.PropertyType.Name&#125;</span>)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 列出所有公共方法</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;\n所有公共方法:&quot;</span>);</span><br><span class="line">        <span class="keyword">foreach</span> (MethodInfo method <span class="keyword">in</span> type.GetMethods(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly))</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;- <span class="subst">&#123;method.Name&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li><strong>动态性</strong>：可以在运行时处理编译时未知的类型</li><li><strong>灵活性</strong>：适合构建通用框架和工具</li><li><strong>解耦</strong>：降低模块间的直接依赖</li><li><strong>可扩展性</strong>：便于实现插件机制</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li><strong>性能开销</strong>：反射操作比直接调用慢很多（通常慢10-100倍）</li><li><strong>类型安全性降低</strong>：编译时无法检查类型错误</li><li><strong>代码可读性差</strong>：反射代码通常比直接调用难理解</li><li><strong>安全问题</strong>：可以访问私有成员，可能破坏封装性</li><li><strong>调试困难</strong>：反射调用的错误在运行时才能发现</li></ol><h2 id="为什么反射的性能开销大？"><a href="#为什么反射的性能开销大？" class="headerlink" title="为什么反射的性能开销大？"></a>为什么反射的性能开销大？</h2><p>反射的性能开销主要来自以下几个方面：</p><h3 id="1-元数据查找开销"><a href="#1-元数据查找开销" class="headerlink" title="1. 元数据查找开销"></a>1. 元数据查找开销</h3><ul><li><strong>运行时搜索</strong>：反射需要在运行时遍历类型的元数据来查找方法、属性、字段等信息</li><li><strong>字符串匹配</strong>：使用字符串名称查找成员（如<code>GetMethod(&quot;MethodName&quot;)</code>）需要进行字符串比较</li><li><strong>无编译器优化</strong>：编译器无法对反射调用进行优化，而直接调用在编译时就已经确定了地址</li></ul><h3 id="2-类型检查和验证"><a href="#2-类型检查和验证" class="headerlink" title="2. 类型检查和验证"></a>2. 类型检查和验证</h3><ul><li><strong>参数验证</strong>：每次反射调用都需要验证参数类型是否匹配</li><li><strong>访问权限检查</strong>：需要检查是否有权限访问该成员（public、private等）</li><li><strong>类型转换</strong>：反射调用的参数通常是<code>object[]</code>，需要进行装箱&#x2F;拆箱操作</li></ul><h3 id="3-安全检查"><a href="#3-安全检查" class="headerlink" title="3. 安全检查"></a>3. 安全检查</h3><ul><li><strong>权限验证</strong>：CLR需要验证调用者是否有足够的权限执行反射操作</li><li><strong>安全栈遍历</strong>：可能需要遍历调用栈来验证安全性</li></ul><h3 id="4-间接调用"><a href="#4-间接调用" class="headerlink" title="4. 间接调用"></a>4. 间接调用</h3><ul><li><strong>无法内联</strong>：直接调用可以被编译器内联优化，而反射调用无法内联</li><li><strong>动态调度</strong>：反射调用通过间接的方式执行，无法利用CPU的分支预测等优化</li></ul><h3 id="5-对象创建开销"><a href="#5-对象创建开销" class="headerlink" title="5. 对象创建开销"></a>5. 对象创建开销</h3><ul><li><strong>装箱操作</strong>：值类型参数需要装箱成<code>object</code></li><li><strong>数组分配</strong>：参数需要封装到<code>object[]</code>数组中</li><li><strong>临时对象</strong>：会产生额外的临时对象和GC压力</li></ul><h3 id="性能对比示例"><a href="#性能对比示例" class="headerlink" title="性能对比示例"></a>性能对比示例</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接调用：约 1-2 纳秒</span></span><br><span class="line">person.SayHello();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反射调用：约 100-200 纳秒</span></span><br><span class="line">methodInfo.Invoke(person, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 性能差距：约 100 倍</span></span><br></pre></td></tr></table></figure><p><strong>总结</strong>：反射的性能开销主要是因为它将编译时的静态操作推迟到了运行时，需要进行大量的查找、验证、类型检查等动态操作，而这些操作在直接调用中都是在编译时完成的。</p><h2 id="性能优化建议"><a href="#性能优化建议" class="headerlink" title="性能优化建议"></a>性能优化建议</h2><ol><li><strong>缓存Type和MemberInfo对象</strong>：避免重复获取</li><li><strong>使用表达式树（Expression Trees）</strong>：比反射快，但仍比直接调用慢</li><li><strong>考虑使用IL Emit</strong>：动态生成IL代码，性能接近原生</li><li><strong>谨慎使用</strong>：仅在必要时使用反射，能用泛型就用泛型</li></ol><h2 id="BindingFlags-常用标志"><a href="#BindingFlags-常用标志" class="headerlink" title="BindingFlags 常用标志"></a>BindingFlags 常用标志</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 公共成员</span></span><br><span class="line">BindingFlags.Public</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非公共成员（private, protected, internal）</span></span><br><span class="line">BindingFlags.NonPublic</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例成员</span></span><br><span class="line">BindingFlags.Instance</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态成员</span></span><br><span class="line">BindingFlags.Static</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅包含当前类声明的成员（不包括继承的）</span></span><br><span class="line">BindingFlags.DeclaredOnly</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组合使用示例</span></span><br><span class="line">type.GetMethods(BindingFlags.Public | BindingFlags.Instance)</span><br><span class="line">type.GetFields(BindingFlags.NonPublic | BindingFlags.Static)</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>反射是C#中非常强大的特性，它让程序具有了自省和动态操作的能力。虽然存在性能开销，但在很多场景下（如框架开发、插件系统），反射带来的灵活性是无可替代的。关键是要在灵活性和性能之间找到合适的平衡点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-反射&quot;&gt;&lt;a href=&quot;#C-反射&quot; class=&quot;headerlink&quot; title=&quot;C#反射&quot;&gt;&lt;/a&gt;C#反射&lt;/h1&gt;&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h</summary>
      
    
    
    
    <category term="C#" scheme="https://siyuewei.github.io/categories/C/"/>
    
    
    <category term="C#" scheme="https://siyuewei.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>虚函数和CRTP</title>
    <link href="https://siyuewei.github.io/2025/10/18/C++/%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8CCRTP/"/>
    <id>https://siyuewei.github.io/2025/10/18/C++/%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8CCRTP/</id>
    <published>2025-10-18T13:49:04.000Z</published>
    <updated>2025-10-28T15:34:37.819Z</updated>
    
    <content type="html"><![CDATA[<h1 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>虚函数是C++实现运行时多态的核心机制。通过在基类中使用<code>virtual</code>关键字声明函数，可以让派生类重写（override）该函数，从而在运行时根据对象的实际类型调用相应的函数实现。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li><strong>动态绑定</strong>：函数调用在运行时根据对象的实际类型确定，而不是编译时的静态类型</li><li><strong>虚函数表（vtable）</strong>：编译器为每个包含虚函数的类生成一个虚函数表，通过虚指针（vptr）指向该表</li><li><strong>性能开销</strong>：由于需要通过虚指针查找虚函数表，存在一定的运行时开销</li><li><strong>灵活性</strong>：派生类可以选择性地重写虚函数，未重写时使用基类的默认实现</li></ul><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>当你需要通过基类指针或引用操作不同派生类对象，并根据对象的实际类型执行不同行为时，虚函数是最佳选择。</p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line"></span><br><span class="line">// 基类</span><br><span class="line">class Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual ~Animal() = default;  // 虚析构函数</span><br><span class="line">    </span><br><span class="line">    virtual void makeSound() const &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Animal makes a sound&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    virtual void move() const &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Animal moves&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 派生类：狗</span><br><span class="line">class Dog : public Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    void makeSound() const override &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Dog barks: Woof! Woof!&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void move() const override &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Dog runs on four legs&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 派生类：猫</span><br><span class="line">class Cat : public Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    void makeSound() const override &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Cat meows: Meow! Meow!&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void move() const override &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Cat walks gracefully&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 派生类：鸟</span><br><span class="line">class Bird : public Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    void makeSound() const override &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Bird chirps: Tweet! Tweet!&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void move() const override &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Bird flies in the sky&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 使用多态</span><br><span class="line">void demonstratePolymorphism(const Animal&amp; animal) &#123;</span><br><span class="line">    animal.makeSound();</span><br><span class="line">    animal.move();</span><br><span class="line">    std::cout &lt;&lt; &quot;---&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Dog dog;</span><br><span class="line">    Cat cat;</span><br><span class="line">    Bird bird;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; &quot;=== 运行时多态演示 ===&quot; &lt;&lt; std::endl;</span><br><span class="line">    demonstratePolymorphism(dog);</span><br><span class="line">    demonstratePolymorphism(cat);</span><br><span class="line">    demonstratePolymorphism(bird);</span><br><span class="line">    </span><br><span class="line">    // 使用指针</span><br><span class="line">    std::cout &lt;&lt; &quot;=== 使用指针 ===&quot; &lt;&lt; std::endl;</span><br><span class="line">    Animal* animals[] = &#123;&amp;dog, &amp;cat, &amp;bird&#125;;</span><br><span class="line">    for (auto* animal : animals) &#123;</span><br><span class="line">        animal-&gt;makeSound();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="CRTP"><a href="#CRTP" class="headerlink" title="CRTP"></a>CRTP</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>CRTP（Curiously Recurring Template Pattern，奇异递归模板模式）是一种编译时多态技术。其核心思想是让派生类作为模板参数传递给基类模板，使得基类可以在编译时访问派生类的成员。</p><h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><ul><li><strong>静态多态</strong>：函数调用在编译时就已确定，无需运行时查找</li><li><strong>零开销</strong>：不需要虚函数表和虚指针，没有运行时性能损耗</li><li><strong>编译期类型检查</strong>：如果派生类没有实现所需的函数，会在编译时报错</li><li><strong>代码膨胀</strong>：每个派生类都会生成独立的代码，可能导致二进制文件增大</li></ul><h2 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h2><p>当你需要在编译期实现多态，追求零开销抽象，且类型关系在编译期就能确定时，CRTP是理想选择。常用于性能敏感的场景，如模板库、数学库等。</p><h2 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename Derived&gt;</span><br><span class="line">class Base &#123;</span><br><span class="line">public:</span><br><span class="line">    void interface() &#123;</span><br><span class="line">        // 调用派生类的实现</span><br><span class="line">        static_cast&lt;Derived*&gt;(this)-&gt;implementation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derived : public Base&lt;Derived&gt; &#123;</span><br><span class="line">public:</span><br><span class="line">    void implementation() &#123;</span><br><span class="line">        // 具体实现</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="虚函数-vs-CRTP-对比"><a href="#虚函数-vs-CRTP-对比" class="headerlink" title="虚函数 vs CRTP 对比"></a>虚函数 vs CRTP 对比</h1><h2 id="主要区别"><a href="#主要区别" class="headerlink" title="主要区别"></a>主要区别</h2><table><thead><tr><th>特性</th><th>虚函数</th><th>CRTP</th></tr></thead><tbody><tr><td>多态类型</td><td>运行时多态</td><td>编译时多态</td></tr><tr><td>性能开销</td><td>有（虚函数表查找）</td><td>无（编译期展开）</td></tr><tr><td>灵活性</td><td>可选择性重写</td><td>必须实现所需函数</td></tr><tr><td>内存开销</td><td>每个对象有虚指针</td><td>无额外指针开销</td></tr><tr><td>代码大小</td><td>较小</td><td>可能较大（模板展开）</td></tr><tr><td>类型安全</td><td>运行时</td><td>编译时</td></tr><tr><td>异构容器</td><td>支持（可用基类指针容器）</td><td>不支持（类型不同）</td></tr></tbody></table><h2 id="选择建议"><a href="#选择建议" class="headerlink" title="选择建议"></a>选择建议</h2><p><strong>使用虚函数的情况：</strong></p><ul><li>需要在运行时动态确定对象类型</li><li>需要将不同类型的对象放在同一个容器中</li><li>派生类可以选择性地实现某些功能</li><li>性能开销可以接受</li></ul><p><strong>使用CRTP的情况：</strong></p><ul><li>追求极致性能，无法接受虚函数开销</li><li>类型关系在编译期就已确定</li><li>需要编译期类型检查和错误提示</li><li>所有派生类都必须实现相同的接口</li></ul><h2 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h2><p>如果虚函数基类中的某一个<code>virtual</code>函数会被所有子类<code>override</code>，那其实就可以用CRTP平替。CRTP要求所有子类都必须实现被调用的函数（否则编译错误），而虚函数的子类可以选择不实现某个虚函数（使用基类的默认实现）。因此，虚函数更灵活，CRTP更高效。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;虚函数&quot;&gt;&lt;a href=&quot;#虚函数&quot; class=&quot;headerlink&quot; title=&quot;虚函数&quot;&gt;&lt;/a&gt;虚函数&lt;/h1&gt;&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p</summary>
      
    
    
    
    <category term="C++" scheme="https://siyuewei.github.io/categories/C/"/>
    
    
    <category term="C++" scheme="https://siyuewei.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>BRDF</title>
    <link href="https://siyuewei.github.io/2025/09/24/Rendering/BRDF/"/>
    <id>https://siyuewei.github.io/2025/09/24/Rendering/BRDF/</id>
    <published>2025-09-24T07:21:00.000Z</published>
    <updated>2025-10-28T15:55:20.959Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BRDF"><a href="#BRDF" class="headerlink" title="BRDF"></a>BRDF</h1><p>BRDF考虑了菲涅尔反射，微表面理论中的法线分布函数、遮蔽函数。</p><h2 id="菲涅尔反射"><a href="#菲涅尔反射" class="headerlink" title="菲涅尔反射"></a>菲涅尔反射</h2><p>当一束光线打到平面后，会同时发生反射和折射，入射光的能量被分散到反射和折射上。</p><p><img src="/../Image/BRDF/LightReflectionAndRefraction.png" alt="光的反射和折射"></p><p>菲涅尔效应（Fresnel Effect）指的是反射随着掠射角(Glancing Angle, 入射光与表面的夹角) 的增大而减小。也即当入射光方向越垂直平面，折射越强；当入射光方向越平行平面，反射越强。</p><p><img src="/../Image/BRDF/FresnelSchematic.png" alt="菲涅尔效应示意图"></p><p>所以看物体在水面的倒影时，离我们远的物体更清楚，因为反射更强，离我们近的物体更模糊，因为反射更弱。</p><h3 id="菲涅尔方程"><a href="#菲涅尔方程" class="headerlink" title="菲涅尔方程"></a>菲涅尔方程</h3><p>菲涅尔方程给出了不同偏振下的反射率。设入射介质折射率为 $n_1$，透射介质为 $n_2$，入射角为 $\theta_i$，折射角为 $\theta_t$，满足斯涅尔定律 $n_1\sin\theta_i &#x3D; n_2\sin\theta_t$。</p><ul><li><p>非导体（介电质，$\kappa&#x3D;0$）：<br>$$<br>R_s &#x3D; \left(\frac{n_1\cos\theta_i - n_2\cos\theta_t}{n_1\cos\theta_i + n_2\cos\theta_t}\right)^2,\quad<br>R_p &#x3D; \left(\frac{n_1\cos\theta_t - n_2\cos\theta_i}{n_1\cos\theta_t + n_2\cos\theta_i}\right)^2<br>$$<br>未偏振光的反射率为 $ R &#x3D; (R_s + R_p)&#x2F;2 $。当 $n_1&gt;n_2$ 且 $\sin\theta_i &gt; n_2&#x2F;n_1$ 时发生全反射：$R&#x3D;1$。</p></li><li><p>导体（复折射率 $\tilde{n}&#x3D;\eta + i\kappa$）：令 $c&#x3D;\cos\theta_i$，则<br>$$<br>R_s &#x3D; \frac{(\eta^2+\kappa^2) - 2\eta c + c^2}{(\eta^2+\kappa^2) + 2\eta c + c^2},\quad<br>R_p &#x3D; \frac{(\eta^2+\kappa^2)c^2 - 2\eta c + 1}{(\eta^2+\kappa^2)c^2 + 2\eta c + 1}<br>$$<br>同样取 $ R &#x3D; (R_s + R_p)&#x2F;2 $。</p></li></ul><p>为实际渲染常用的近似：</p><ul><li><p>Schlick 近似（介电质）：<br>$$<br>R(\theta_i) &#x3D; R_0 + (1-R_0)(1-\cos\theta_i)^5,\quad<br>R_0 &#x3D; \left(\frac{n_1-n_2}{n_1+n_2}\right)^2<br>$$</p></li><li><p>Schlick 近似（导体，按通道）：<br>$$<br>R_0 &#x3D; \frac{(\eta-1)^2+\kappa^2}{(\eta+1)^2+\kappa^2}<br>$$</p></li></ul><h2 id="微表面理论"><a href="#微表面理论" class="headerlink" title="微表面理论"></a>微表面理论</h2><p>微表面模型是把宏观上的一块平面，看成若干个微小有起伏的平面的组合。<br>如下图所示，dS层可以看作宏观上的平面，dA层则是微观上的若干个微表面。</p><p><img src="/../Image/BRDF/MicrosurfaceSchematic.png" alt="微表面模型示意图"></p><h3 id="法线分布函数（NDF，Normal-Distribution-Function）"><a href="#法线分布函数（NDF，Normal-Distribution-Function）" class="headerlink" title="法线分布函数（NDF，Normal Distribution Function）"></a>法线分布函数（NDF，Normal Distribution Function）</h3><p>对于每一个微表面，都有自己的微表面法线$m$，表面的宏观法线一般表示为$n$。法线分布函数是用来描述微表面法线的分布情况的函数$D(m)$。</p><p>法线分布函数是对微表面法线在微观几何表面上的统计分布，即$D(m)$表示法线方向为$m$的微表面在微观几何中的密度。</p><p>法线分布函数有如下性质：</p><ul><li>法线分布函数与微平面法线的积分为微表面面积。</li></ul><p><img src="/../Image/BRDF/%E6%80%A7%E8%B4%A81.png" alt="性质1"></p><p>$$<br>A_{\text{micro}}<br>&#x3D; \int_{\Omega^+} D(m),\mathrm{d}\omega_m ;;\ge; 1<br>\quad (\text{以宏观单位面积为基准})<br>$$</p><ul><li>微平面法线投影到宏观表面上面积的积分为宏观表面面积(规定为1)。</li></ul><p><img src="/../Image/BRDF/MicrosurfaceSchematic.png" alt="性质2"></p><p>$$<br>\int_{\Omega^+} D(m),\big(n\cdot m\big),\mathrm{d}\omega_m<br>&#x3D; 1<br>$$</p><ul><li>微表面法线投影到视角垂平面等效于宏观法线投影到视角垂平面。</li></ul><p><img src="/../Image/BRDF/%E6%80%A7%E8%B4%A83.png" alt="性质3"></p><p>设视线方向为 $v$ 且 $n\cdot v&gt;0$，则有<br>$$<br>\int_{\Omega^+} D(m),\max!\big(0,,v\cdot m\big),\mathrm{d}\omega_m<br>&#x3D; n\cdot v<br>$$</p><h4 id="常见的法线函数"><a href="#常见的法线函数" class="headerlink" title="常见的法线函数"></a>常见的法线函数</h4><p>设半程向量为 $h$，宏观法线为 $n$，$c&#x3D;n\cdot h&#x3D;\cos\theta_h$。</p><ul><li><p>Phong（经典各向同性）：<br>$$<br>D_{\text{Phong}}(h) &#x3D; \frac{n_p+2}{2\pi},c^{,n_p}\quad (c&gt;0)<br>$$</p></li><li><p>Beckmann（高斯斜率）：<br>$$<br>D_{\text{Beck}}(h) &#x3D; \frac{\exp!\left(-\tan^2!\theta_h&#x2F;\alpha^2\right)}{\pi,\alpha^2,c^{4}}<br>$$</p></li><li><p>GGX &#x2F; Trowbridge–Reitz：<br>$$<br>D_{\text{GGX}}(h) &#x3D; \frac{\alpha^2}{\pi,\big[(\alpha^2-1),c^2 + 1\big]^2}<br>$$</p></li><li><p>各向异性 GGX（切线空间粗糙度 $\alpha_x,\alpha_y$）：<br>$$<br>D_{\text{GGX-aniso}}(h) &#x3D; \frac{1}{\pi,\alpha_x\alpha_y,\Big[\big(h_x&#x2F;\alpha_x\big)^2 + \big(h_y&#x2F;\alpha_y\big)^2 + h_z^2\Big]^2}<br>$$</p></li></ul><p>参数与粗糙度的常用近似关系（经验）：<br>$$<br>\alpha \approx \text{roughness}^2,\qquad n_p \approx \frac{2}{\alpha^2}-2<br>$$<br>其中 $\text{roughness}\in[0,1]$ 为艺术参数，$n_p$ 为 Phong 指数。</p><h3 id="联合遮蔽-阴影函数-joint-masking-shadowing-function"><a href="#联合遮蔽-阴影函数-joint-masking-shadowing-function" class="headerlink" title="联合遮蔽-阴影函数(joint masking-shadowing function)"></a>联合遮蔽-阴影函数(joint masking-shadowing function)</h3><p>在微表面模型中，光线在微表面上的弹射会导致遮挡，有 $Shadowing$ 和 $Masking$ 两种情况。$Shadowing$ 是入射光被微表面遮挡，$Masking$ 是反射光被微表面遮挡。一般用 $G_1(v,m)$ 表示 Masking。</p><p><img src="/../Image/BRDF/%E5%85%89%E5%9C%A8%E5%BE%AE%E8%A1%A8%E9%9D%A2%E7%9A%84%E5%BC%B9%E5%B0%84.png" alt="光在微表面的弹射"></p><p>同时考虑 $Shadowing$ 和 $Masking$ 两种情况的函数被称为联合遮蔽-阴影函数 $G_2(l,v,m)$，也被称为几何函数。</p><p>实际应用中，常用 $The Smith Shadow-Masking G2$ 函数，它将$Shadowing$和$Masking$分开考虑。由于光路的可逆性，我们可以认为两种情况是近似等效的，因为用 $G_1(v,m)$ 表示$ Masking$，则用$G_1(l,m)$ 表示 $Shadowing$。</p><p>$$<br>G_2(l,v,m) &#x3D; G_1(v,m),G_1(l,m)<br>$$</p><p>它建立在Shadowing和Masking不相关的基础上，但实际上它们是相关的。使用这个G2会导致BRDFs结果偏暗。</p><h2 id="宏观BRDF"><a href="#宏观BRDF" class="headerlink" title="宏观BRDF"></a>宏观BRDF</h2><p>基于微表面理论，给出微BRDF $f_{u}(l,v,m)$，法线分布函数$D(m)$，联合遮蔽-阴影函数$G_2(l,v,m)$，可以推出宏观BRDF</p><p>$$<br>f(l,v) &#x3D; \int_{m \in \Omega^+} f_{u}(l,v,m),D(m),G_2(l,v,m),\frac{\max(0,,m\cdot l)}{|n\cdot l|},\frac{\max(0,,m\cdot v)}{|n\cdot v|},\mathrm{d}\omega_m<br>$$</p><p>$\frac{\max(0,,m\cdot l)}{|n\cdot l|}$,$\frac{\max(0,,m\cdot v)}{|n\cdot v|}$是为了归一化。</p><h2 id="镜面反射BRDF"><a href="#镜面反射BRDF" class="headerlink" title="镜面反射BRDF"></a>镜面反射BRDF</h2><p>在镜面微面元模型下，每个微平面都是一个完美的菲涅尔镜(Fresnel mirror)。只有当微平面的法线 $m$ 与 $l$ 和 $v$ 的半程向量 $h &#x3D; \frac{l+v}{\lVert l+v\rVert}$ 一致时，该微面元才把能量反射进视线方向。</p><p><img src="/../Image/BRDF/%E8%8F%B2%E6%B6%85%E5%B0%94%E9%95%9C.png" alt="菲涅尔镜"></p><p>$$<br>h &#x3D; \frac{l+v}{\lVert l+v\rVert},\quad m &#x3D; h,\quad n\cdot l&gt;0,; n\cdot v&gt;0,; l\cdot m&gt;0,; v\cdot m&gt;0<br>$$<br>等价的反射约束写法为：<br>$$<br>v &#x3D; 2,(m\cdot l),m - l<br>$$</p><h1 id="一种常用的BRDF——Cook-Torrance-BRDF"><a href="#一种常用的BRDF——Cook-Torrance-BRDF" class="headerlink" title="一种常用的BRDF——Cook Torrance BRDF"></a>一种常用的BRDF——Cook Torrance BRDF</h1><p>Cook-Torrance BRDF兼有漫反射和镜面反射两个部分：</p><p>$$<br>f_{r} &#x3D; k_{d}f_{lambert} + k_{s}f_{cook-torrance}<br>$$</p><ul><li>$k_{d}$表示入射光线中，被折射部分能量的比率</li><li>$k_{s}$表示反射光线中，被反射部分的比率</li><li>$k_{d}$ 和 $k_{s}$一般由艺术家设置，不同的材质，这两个参数的值不同</li></ul><h2 id="漫反射"><a href="#漫反射" class="headerlink" title="漫反射"></a>漫反射</h2><p>$$<br>f_{lambert} &#x3D; \frac{c}{\pi}<br>$$</p><ul><li>$c$表示表面颜色</li><li>$\pi$ 是为了对漫反射光标准化，因为前面含有BRDF的积分方程是受 $\pi$ 影响的</li></ul><p>Lambertian漫反射模型已经足够应付大多数实时渲染的用途了</p><h2 id="镜面反射"><a href="#镜面反射" class="headerlink" title="镜面反射"></a>镜面反射</h2><p>对于Cook Torrance BRDF，<br>半程向量 $h&#x3D;\dfrac{l+v}{\lVert l+v\rVert}$，取理想镜面微 BRDF 为<br>$$<br>f_u(l,v,m)&#x3D;<br>\begin{cases}<br>\dfrac{F(v,m)}{4,|v\cdot m|,|l\cdot m|}, &amp; m &#x3D; h \<br>0, &amp; m \ne h<br>\end{cases}<br>$$<br>代入宏观BRDF积分<br>$$<br>f(l,v) &#x3D; \int_{m \in \Omega^+} f_{u}(l,v,m),D(m),G_2(l,v,m),\frac{\max(0,,m\cdot l)}{|n\cdot l|},\frac{\max(0,,m\cdot v)}{|n\cdot v|},\mathrm{d}\omega_m<br>$$<br>可得<br>$$<br>f_{cook-torrance}(l,v) &#x3D; \frac{D(h),G_2(l,v,h),F(v,h)}{4,|n\cdot l|,|n\cdot v|}<br>$$</p><h2 id="最终公式"><a href="#最终公式" class="headerlink" title="最终公式"></a>最终公式</h2><p>$$<br>f_{r} &#x3D; k_{d}\frac{c}{\pi} + k_{s}\frac{D(h),G_2(l,v,h),F(v,h)}{4,|n\cdot l|,|n\cdot v|}<br>$$</p><p>一般而言，</p><ul><li><p>D公式选用Trowbridge-Reitz GGX函数近似<br>$$<br>D_{\text{GGX}}(h) &#x3D; \frac{\alpha^2}{\pi,\big[(\alpha^2-1),c^2 + 1\big]^2}<br>$$<br>$\alpha$为粗糙度。</p></li><li><p>F项选用schilick近似<br>$$<br>F_{schilick}(v,h,F_0) &#x3D; F_0 + (1-F_0),\big(1- v\cdot h\big)^5<br>$$</p></li><li><p>G的公式选用schlick-GGX近似<br>$$<br>G_{ggx}(n,v,k) &#x3D; \frac{n \cdot v}{(n \cdot v)(1-k) + k}<br>$$</p></li></ul><p>$k$ 是一个和粗糙度roughness有关的常数。 一个完整的G函数由两部分组成:</p><p>$$<br>G(n, v, l, k) \approx G_{ggx}(n,v,k) G_{ggx}(n,l,k)<br>$$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vec3 evaluateSpecular(...)</span><br><span class="line">&#123;</span><br><span class="line">    //计算光线达到点p处的能量</span><br><span class="line">    float radiance = evaluateRadiance(light, pixel); </span><br><span class="line"></span><br><span class="line">    float NDF = evaluateDistributionGGX(...);  //法线方程  </span><br><span class="line">    float G   = evaluateGeometrySmith(...);    //几何函数</span><br><span class="line">    vec3 F    = evaluateFresnelSchlick(...);   //菲涅尔函数</span><br><span class="line"></span><br><span class="line">    float denominator = ...;  //根据一些参数计算出一个常量</span><br><span class="line">    vec3 specular = NDF * G * F / denominator;</span><br><span class="line"></span><br><span class="line">    return specular;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>知乎专栏合集：BRDF&#x2F;渲染相关 <a href="https://zhuanlan.zhihu.com/c_1647165706373316609">链接</a></li><li>知识库&#x2F;计算机图形学&#x2F;Cook Torrance BRDF <a href="https://geodoer.github.io/A-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/2-%E6%B8%B2%E6%9F%93%E6%A6%82%E8%BF%B0/%E5%85%89%E7%85%A7%E4%B8%8E%E6%9D%90%E8%B4%A8/PBR/PBR%E5%8E%9F%E7%90%86/BRDF/Cook-Torrance%20BRDF/">链接</a></li><li>PBR渲染: Cook-Torrance的实现与补充 <a href="https://www.blurredcode.com/2021/05/dec701b2/#%e5%87%a0%e4%bd%95%e9%81%ae%e8%94%bd%e9%a1%b9g">链接</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;BRDF&quot;&gt;&lt;a href=&quot;#BRDF&quot; class=&quot;headerlink&quot; title=&quot;BRDF&quot;&gt;&lt;/a&gt;BRDF&lt;/h1&gt;&lt;p&gt;BRDF考虑了菲涅尔反射，微表面理论中的法线分布函数、遮蔽函数。&lt;/p&gt;
&lt;h2 id=&quot;菲涅尔反射&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="Rendering" scheme="https://siyuewei.github.io/categories/Rendering/"/>
    
    
    <category term="Rendering" scheme="https://siyuewei.github.io/tags/Rendering/"/>
    
  </entry>
  
  <entry>
    <title>RayTracing</title>
    <link href="https://siyuewei.github.io/2025/09/22/Rendering/RayTracing/"/>
    <id>https://siyuewei.github.io/2025/09/22/Rendering/RayTracing/</id>
    <published>2025-09-22T03:03:32.000Z</published>
    <updated>2025-10-29T09:17:02.160Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RayTracing概述"><a href="#RayTracing概述" class="headerlink" title="RayTracing概述"></a>RayTracing概述</h1><h2 id="渲染方程"><a href="#渲染方程" class="headerlink" title="渲染方程"></a>渲染方程</h2><p>每个点的Radiance &#x3D; 该点的自发光Radiance + 该点反射出的 来自其他光源的Radiance。</p><p>$$L_o(p,\omega_o) &#x3D; L_e(p,\omega_o) + \int_{\Omega} f_r(p,\omega_i,\omega_o) L_i(p,\omega_i) \cos\theta_i d\omega_i$$ </p><p>其中：</p><ul><li>$p$ 是表面上的点（point on surface）</li><li>$\omega_o$ 是出射方向（outgoing direction）</li><li>$\omega_i$ 是入射方向（incoming direction）</li><li>$L_o(p,\omega_o)$ 是从点 $p$ 沿方向 $\omega_o$ 出射的辐射度（outgoing radiance）</li><li>$L_e(p,\omega_o)$ 是点 $p$ 沿方向 $\omega_o$ 的自发光辐射度（emitted radiance）</li><li>$f_r(p,\omega_i,\omega_o)$ 是双向反射分布函数（BRDF - Bidirectional Reflectance Distribution Function）</li><li>$L_i(p,\omega_i)$ 是从方向 $\omega_i$ 入射到点 $p$ 的辐射度（incoming radiance）</li><li>$\cos\theta_i$ 是入射角 $\theta_i$ 的余弦值，表示光线与表面法线的夹角</li><li>$\Omega$ 是半球积分域（hemisphere integration domain）</li><li>$d\omega_i$ 是立体角微元（solid angle differential）</li></ul><h3 id="物理意义解释"><a href="#物理意义解释" class="headerlink" title="物理意义解释"></a>物理意义解释</h3><p>渲染方程描述了光线在表面上的反射行为：</p><ol><li><strong>自发光项</strong> $L_e(p,\omega_o)$：表示表面本身发出的光，如灯泡、火焰等光源</li><li><strong>反射项</strong> $\int_{\Omega} f_r(p,\omega_i,\omega_o) L_i(p,\omega_i) \cos\theta_i d\omega_i$：<ul><li>积分表示对所有可能入射方向的贡献求和</li><li>BRDF $f_r$ 描述材料如何将入射光反射到出射方向</li><li>$\cos\theta_i$ 项体现了朗伯定律（Lambert’s law），入射角越大，贡献越小</li><li>这个积分计算了来自所有方向的光线对出射辐射度的贡献</li></ul></li></ol><h3 id="数学含义"><a href="#数学含义" class="headerlink" title="数学含义"></a>数学含义</h3><ul><li>这是一个<strong>积分方程</strong>，因为 $L_i$ 本身可能依赖于其他表面的 $L_o$</li><li>在全局光照中，这个方程需要递归求解</li><li>在光线追踪中，我们通过采样来近似这个积分</li></ul><h2 id="BRDF（双向反射分布函数）"><a href="#BRDF（双向反射分布函数）" class="headerlink" title="BRDF（双向反射分布函数）"></a>BRDF（双向反射分布函数）</h2><p>BRDF $f_r(p,\omega_i,\omega_o)$ 描述了材料如何将入射光反射到出射方向。它满足以下性质：</p><h3 id="1-能量守恒"><a href="#1-能量守恒" class="headerlink" title="1. 能量守恒"></a>1. 能量守恒</h3><p>$$\int_{\Omega} f_r(p,\omega_i,\omega_o) \cos\theta_i d\omega_i \leq 1$$</p><h3 id="2-互易性（Helmholtz互易性）"><a href="#2-互易性（Helmholtz互易性）" class="headerlink" title="2. 互易性（Helmholtz互易性）"></a>2. 互易性（Helmholtz互易性）</h3><p>$$f_r(p,\omega_i,\omega_o) &#x3D; f_r(p,\omega_o,\omega_i)$$</p><h3 id="3-常见BRDF模型"><a href="#3-常见BRDF模型" class="headerlink" title="3. 常见BRDF模型"></a>3. 常见BRDF模型</h3><p><strong>朗伯反射（Lambertian）</strong>：<br>$$f_r(p,\omega_i,\omega_o) &#x3D; \frac{\rho}{\pi}$$</p><p>其中 $\rho$ 是反射率（albedo）。</p><p><strong>镜面反射（Specular）</strong>：<br>$$f_r(p,\omega_i,\omega_o) &#x3D; \frac{F(\theta_h) D(\theta_h) G(\omega_i,\omega_o)}{4\cos\theta_i\cos\theta_o}$$</p><p>其中：</p><ul><li>$F$ 是菲涅尔反射系数</li><li>$D$ 是法线分布函数</li><li>$G$ 是几何遮蔽函数</li></ul><h2 id="PDF（概率密度函数）解释"><a href="#PDF（概率密度函数）解释" class="headerlink" title="PDF（概率密度函数）解释"></a>PDF（概率密度函数）解释</h2><p>PDF（Probability Density Function）是蒙特卡洛积分中的关键概念：</p><h3 id="什么是PDF？"><a href="#什么是PDF？" class="headerlink" title="什么是PDF？"></a>什么是PDF？</h3><ul><li><strong>定义</strong>：PDF $p(\omega_i)$ 描述在方向 $\omega_i$ 上采样的概率密度</li><li><strong>作用</strong>：告诉我们在哪个方向更可能采样到重要的光线</li><li><strong>归一化</strong>：$\int_{\Omega} p(\omega_i) d\omega_i &#x3D; 1$</li></ul><h3 id="为什么需要PDF？"><a href="#为什么需要PDF？" class="headerlink" title="为什么需要PDF？"></a>为什么需要PDF？</h3><p>在渲染方程中：<br>$$L_o(p,\omega_o) &#x3D; L_e(p,\omega_o) + \int_{\Omega} f_r(p,\omega_i,\omega_o) L_i(p,\omega_i) \cos\theta_i d\omega_i$$</p><p>我们通过随机采样来近似这个积分：<br>$$\approx L_e(p,\omega_o) + \frac{1}{N} \sum_{i&#x3D;1}^{N} \frac{f_r(p,\omega_i,\omega_o) L_i(p,\omega_i) \cos\theta_i}{p(\omega_i)}$$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">总贡献 = 0</span><br><span class="line">for i = 1 to N:</span><br><span class="line">    ω = 根据PDF随机选择一个方向</span><br><span class="line">    贡献 = fr(ω) * Li(ω) * cos(θ) / pdf(ω)</span><br><span class="line">    总贡献 += 贡献</span><br><span class="line">最终结果 = 总贡献 / N</span><br></pre></td></tr></table></figure><h3 id="常见PDF策略"><a href="#常见PDF策略" class="headerlink" title="常见PDF策略"></a>常见PDF策略</h3><ol><li><strong>均匀采样</strong>：$p(\omega_i) &#x3D; \frac{1}{2\pi}$（所有方向等概率）</li><li><strong>余弦加权采样</strong>：$p(\omega_i) &#x3D; \frac{\cos\theta_i}{\pi}$（更可能采样接近法线的方向）</li><li><strong>BRDF采样</strong>：$p(\omega_i) \propto f_r(p,\omega_i,\omega_o)$（根据BRDF形状采样）</li><li><strong>光源采样</strong>：$p(\omega_i) \propto \frac{1}{d^2}$（更可能采样距离近的光源方向）</li></ol><h3 id="光源采样详解"><a href="#光源采样详解" class="headerlink" title="光源采样详解"></a>光源采样详解</h3><p>光源采样是一种重要的优化技术，直接向光源方向采样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 光源采样伪代码</span><br><span class="line">Vector3 sampleLight(Point p) &#123;</span><br><span class="line">    // 选择光源</span><br><span class="line">    Light light = selectLight();</span><br><span class="line">    </span><br><span class="line">    // 计算从p到光源的方向</span><br><span class="line">    Vector3 lightDir = normalize(light.position - p);</span><br><span class="line">    </span><br><span class="line">    // 计算距离</span><br><span class="line">    float distance = length(light.position - p);</span><br><span class="line">    </span><br><span class="line">    // 计算PDF（考虑距离衰减）</span><br><span class="line">    float pdf = 1.0 / (distance * distance);</span><br><span class="line">    </span><br><span class="line">    return lightDir;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在shade函数中使用</span><br><span class="line">shade(p, wo) &#123;</span><br><span class="line">    Lo = Le(p, wo)</span><br><span class="line">    </span><br><span class="line">    // 1. 光源采样（直接光照）</span><br><span class="line">    Vector3 wi_light = sampleLight(p);</span><br><span class="line">    Ray shadowRay(p, wi_light);</span><br><span class="line">    if (!intersect(shadowRay)) &#123;</span><br><span class="line">        float cosTheta = dot(normal, wi_light);</span><br><span class="line">        Lo += fr(p,wi_light,wo) * light.intensity * cosTheta / pdf_light;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 2. BRDF采样（间接光照）</span><br><span class="line">    Vector3 wi_brdf = sampleBRDF(wo);</span><br><span class="line">    // ... 递归计算</span><br><span class="line">    </span><br><span class="line">    return Lo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多重重要性采样（MIS）"><a href="#多重重要性采样（MIS）" class="headerlink" title="多重重要性采样（MIS）"></a>多重重要性采样（MIS）</h3><p>结合光源采样和BRDF采样，使用权重函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 权重函数</span><br><span class="line">float powerHeuristic(float pdf1, float pdf2) &#123;</span><br><span class="line">    float w1 = pdf1 * pdf1;</span><br><span class="line">    float w2 = pdf2 * pdf2;</span><br><span class="line">    return w1 / (w1 + w2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在shade函数中</span><br><span class="line">shade(p, wo) &#123;</span><br><span class="line">    Lo = Le(p, wo)</span><br><span class="line">    </span><br><span class="line">    // 光源采样</span><br><span class="line">    Vector3 wi_light = sampleLight(p);</span><br><span class="line">    float pdf_light = lightPdf(wi_light);</span><br><span class="line">    float pdf_brdf = brdfPdf(wi_light, wo);</span><br><span class="line">    float weight_light = powerHeuristic(pdf_light, pdf_brdf);</span><br><span class="line">    </span><br><span class="line">    // BRDF采样  </span><br><span class="line">    Vector3 wi_brdf = sampleBRDF(wo);</span><br><span class="line">    float pdf_brdf2 = brdfPdf(wi_brdf, wo);</span><br><span class="line">    float pdf_light2 = lightPdf(wi_brdf);</span><br><span class="line">    float weight_brdf = powerHeuristic(pdf_brdf2, pdf_light2);</span><br><span class="line">    </span><br><span class="line">    // 加权求和</span><br><span class="line">    Lo += weight_light * evaluateLightContribution(wi_light);</span><br><span class="line">    Lo += weight_brdf * evaluateBRDFContribution(wi_brdf);</span><br><span class="line">    </span><br><span class="line">    return Lo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重要性采样"><a href="#重要性采样" class="headerlink" title="重要性采样"></a>重要性采样</h3><ul><li><strong>目标</strong>：减少噪声，提高收敛速度</li><li><strong>原理</strong>：在贡献大的区域多采样，在贡献小的区域少采样</li><li><strong>效果</strong>：相同样本数下获得更准确的结果</li></ul><h2 id="直接光照"><a href="#直接光照" class="headerlink" title="直接光照"></a>直接光照</h2><p>只考虑直接光照的光追，是从屏幕每个pixel发出射线，射线方向是viewpoint-&gt;pixel，计算每条光线上的Radiance。如果光线打到光源，则增加Radiance的值。</p><p>对于直接光照，渲染方程简化为：</p><p>$$L_o(p,\omega_o) &#x3D; L_e(p,\omega_o) + \sum_{i&#x3D;1}^{n} f_r(p,\omega_i,\omega_o) L_i(p,\omega_i) \cos\theta_i$$</p><p>其中：</p><ul><li>$L_o(p,\omega_o)$ 是出射辐射度（outgoing radiance）</li><li>$L_e(p,\omega_o)$ 是自发光辐射度（emitted radiance）</li><li>$f_r(p,\omega_i,\omega_o)$ 是BRDF（双向反射分布函数）</li><li>$L_i(p,\omega_i)$ 是入射辐射度（incoming radiance）</li><li>$\cos\theta_i$ 是入射角余弦值</li><li>$n$ 是光源数量</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">shade(p,w0)</span><br><span class="line">    Lo = Le(p,wo)  // 自发光项</span><br><span class="line">    Randomly sample N directions wi (i=1 to N) based on the pdf</span><br><span class="line">    For each wi</span><br><span class="line">        Trace a ray r(p,wi)</span><br><span class="line">        if ray hit a light</span><br><span class="line">            Lo += (1/N) * fr(p,wi,wo) * Li(p,wi) * cos(θi) / pdf(wi)</span><br><span class="line">    return Lo</span><br></pre></td></tr></table></figure><h2 id="全局光照"><a href="#全局光照" class="headerlink" title="全局光照"></a>全局光照</h2><p>不仅仅只考虑打到光源的光线，如果光线打到某个物体上，则把这个物体也当作一个起点，发散$N$条光线，看是否接触到光源，或是别的物体。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">shade(p,w0)</span><br><span class="line">    Lo = Le(p,wo)  // 自发光项</span><br><span class="line">    Randomly sample N directions wi (i=1 to N) based on the pdf</span><br><span class="line">    For each wi</span><br><span class="line">        Trace a ray r(p,wi)</span><br><span class="line">        if ray hit a light</span><br><span class="line">            Lo += (1/N) * fr(p,wi,wo) * Li(p,wi) * cos(θi) / pdf(wi)</span><br><span class="line">        else if ray hit an object at q</span><br><span class="line">            Lo += (1/N) * shade(q, -wi) * f_r * cos(θi) / pdf(wi)</span><br><span class="line">    return Lo</span><br></pre></td></tr></table></figure><p><img src="/../Image/RayTracing/RayTracingForGlobal.png" alt="考虑全局光照的光追"></p><p>光线的传播如下图所示，性能爆炸：<br><img src="/../Image/RayTracing/LightTrace.png" alt="光线传播"></p><h2 id="路径追踪（一个具体的光追算法）"><a href="#路径追踪（一个具体的光追算法）" class="headerlink" title="路径追踪（一个具体的光追算法）"></a>路径追踪（一个具体的光追算法）</h2><p>在全局光照中，如果取$N &#x3D; 1$，那么这个算法就被称为路径追踪</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">shade(p,w0)</span><br><span class="line">    Lo = Le(p,wo)  // 自发光项</span><br><span class="line">    Randomly choose ONE direction wi(i=1) base on pdf</span><br><span class="line">    Trace a ray r(p,wi)</span><br><span class="line">    if ray hit a light</span><br><span class="line">        Lo += fr(p,wi,wo) * Li(p,wi) * cos(θi) / pdf(wi)</span><br><span class="line">    else if ray hit an object at q</span><br><span class="line">        Lo += shade(q, -wi) * f_r * cos(θi) / pdf(wi)</span><br><span class="line">    return Lo</span><br></pre></td></tr></table></figure><h2 id="Ray-Generation"><a href="#Ray-Generation" class="headerlink" title="Ray Generation"></a>Ray Generation</h2><p>上面讲的是从viewpoint to piexl打出一条光线后，这条光线如何计算。这里讲从viewpoint to piexl的光线是如何生成的，以及如何计算最终的渲染结果。一个pixel也可以打出若干条光线。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ray_generation(camPos，pixel)</span><br><span class="line">    Uniformly choose N sample positions within the pixel</span><br><span class="line">    pixel_radiance = 0.0</span><br><span class="line">    for each sample in the pixel:</span><br><span class="line">        Shoot a ray r(camPos, camPos_to_sample)</span><br><span class="line">        if ray r hit p（object or light）</span><br><span class="line">            pixel_radiance += 1/N * shade(p，sample_to_camPos)</span><br><span class="line">    return pixel_radiance</span><br></pre></td></tr></table></figure><p>这里p不需要区分是光源还是普通物体，因为shade函数已经包含了自发光项$L_e(p,\omega_o)$，能够统一处理两种情况：</p><ul><li>如果p是光源，自发光项会返回光源的辐射度</li><li>如果p是普通物体，自发光项为零，只计算反射光</li></ul><h2 id="算法停止"><a href="#算法停止" class="headerlink" title="算法停止"></a>算法停止</h2><h3 id="俄罗斯轮盘赌（Russian-Roulette）"><a href="#俄罗斯轮盘赌（Russian-Roulette）" class="headerlink" title="俄罗斯轮盘赌（Russian Roulette）"></a>俄罗斯轮盘赌（Russian Roulette）</h3><p>在光线追踪中，递归可能无限进行下去，需要一种机制来停止算法。俄罗斯轮盘赌是一种概率终止方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">shade(p, wo, depth) </span><br><span class="line">    // 俄罗斯轮盘赌：设定一个概率值continue_probability，随机取一个[0,1]的random()值</span><br><span class="line">    if random() &gt; continue_probability:</span><br><span class="line">        return 0.0;  // 终止递归</span><br><span class="line">    </span><br><span class="line">    Lo = Le(p, wo)  // 自发光项</span><br><span class="line">    Randomly sample ONE direction wi based on pdf</span><br><span class="line">    Trace a ray r(p, wi)</span><br><span class="line">    if ray hit a light:</span><br><span class="line">        Lo += fr(p,wi,wo) * Li(p,wi) * cos(θi) / pdf(wi)</span><br><span class="line">    else if ray hit an object at q:</span><br><span class="line">        Lo += shade(q, -wi, depth+1) * fr(p,wi,wo) * cos(θi) / pdf(wi)</span><br><span class="line">    </span><br><span class="line">    // 补偿能量：除以继续概率</span><br><span class="line">    return Lo / continue_probability</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;RayTracing概述&quot;&gt;&lt;a href=&quot;#RayTracing概述&quot; class=&quot;headerlink&quot; title=&quot;RayTracing概述&quot;&gt;&lt;/a&gt;RayTracing概述&lt;/h1&gt;&lt;h2 id=&quot;渲染方程&quot;&gt;&lt;a href=&quot;#渲染方程&quot; cla</summary>
      
    
    
    
    <category term="Rendering" scheme="https://siyuewei.github.io/categories/Rendering/"/>
    
    
    <category term="Rendering" scheme="https://siyuewei.github.io/tags/Rendering/"/>
    
  </entry>
  
  <entry>
    <title>Hexo</title>
    <link href="https://siyuewei.github.io/2025/09/04/Tools/Hexo/"/>
    <id>https://siyuewei.github.io/2025/09/04/Tools/Hexo/</id>
    <published>2025-09-03T16:35:50.000Z</published>
    <updated>2025-10-28T15:34:37.816Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo-静态博客框架使用指南"><a href="#Hexo-静态博客框架使用指南" class="headerlink" title="Hexo 静态博客框架使用指南"></a>Hexo 静态博客框架使用指南</h1><p>Hexo 是一个快速、简洁且高效的博客框架，基于 Node.js 构建。它可以将 Markdown 文件渲染成静态网页，支持多种主题和插件。</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建新文章</span></span><br><span class="line">hexo new <span class="string">&quot;文章标题&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建新页面</span></span><br><span class="line">hexo new page <span class="string">&quot;页面名称&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建草稿</span></span><br><span class="line">hexo new draft <span class="string">&quot;草稿标题&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成静态文件</span></span><br><span class="line">hexo generate</span><br><span class="line"><span class="comment"># 或简写</span></span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动本地服务器</span></span><br><span class="line">hexo server</span><br><span class="line"><span class="comment"># 或简写</span></span><br><span class="line">hexo s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署到服务器</span></span><br><span class="line">hexo deploy</span><br><span class="line"><span class="comment"># 或简写</span></span><br><span class="line">hexo d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理缓存和生成的文件</span></span><br><span class="line">hexo clean</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一键生成并部署</span></span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><h3 id="草稿相关命令"><a href="#草稿相关命令" class="headerlink" title="草稿相关命令"></a>草稿相关命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发布草稿</span></span><br><span class="line">hexo publish <span class="string">&quot;草稿文件名&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 预览草稿</span></span><br><span class="line">hexo server --draft</span><br></pre></td></tr></table></figure><h3 id="主题管理"><a href="#主题管理" class="headerlink" title="主题管理"></a>主题管理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装主题</span></span><br><span class="line">git <span class="built_in">clone</span> &lt;theme-repository-url&gt; themes/&lt;theme-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新主题</span></span><br><span class="line"><span class="built_in">cd</span> themes/&lt;theme-name&gt;</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><h2 id="配置文件说明"><a href="#配置文件说明" class="headerlink" title="配置文件说明"></a>配置文件说明</h2><h3 id="config-yml-主要配置项"><a href="#config-yml-主要配置项" class="headerlink" title="_config.yml 主要配置项"></a>_config.yml 主要配置项</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 网站基本信息</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">网站标题</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">网站副标题</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">网站描述</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">关键词</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">作者名</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># URL 设置</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://your-domain.com</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 目录设置</span></span><br><span class="line"><span class="attr">source_dir:</span> <span class="string">source</span></span><br><span class="line"><span class="attr">public_dir:</span> <span class="string">public</span></span><br><span class="line"><span class="attr">skip_render:</span> []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写作设置</span></span><br><span class="line"><span class="attr">new_post_name:</span> <span class="string">:title.md</span></span><br><span class="line"><span class="attr">default_layout:</span> <span class="string">post</span></span><br><span class="line"><span class="attr">auto_spacing:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">titlecase:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分类和标签</span></span><br><span class="line"><span class="attr">default_category:</span> <span class="string">uncategorized</span></span><br><span class="line"><span class="attr">category_map:</span></span><br><span class="line"><span class="attr">tag_map:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 日期格式</span></span><br><span class="line"><span class="attr">date_format:</span> <span class="string">YYYY-MM-DD</span></span><br><span class="line"><span class="attr">time_format:</span> <span class="string">HH:mm:ss</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分页设置</span></span><br><span class="line"><span class="attr">per_page:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">pagination_dir:</span> <span class="string">page</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主题设置</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署设置</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">&lt;repository-url&gt;</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure><h2 id="文章写作"><a href="#文章写作" class="headerlink" title="文章写作"></a>文章写作</h2><h3 id="Front-matter-格式"><a href="#Front-matter-格式" class="headerlink" title="Front-matter 格式"></a>Front-matter 格式</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">文章标题</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2025-09-04 00:35:50</span></span><br><span class="line"><span class="attr">updated:</span> <span class="number">2025-09-04 00:35:50</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">标签1</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">标签2</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">分类1</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">分类2</span></span><br><span class="line"><span class="attr">comments:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">toc:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">toc_number:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">toc_style_simple:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">mathjax:</span> <span class="literal">true</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="string">文章内容...</span></span><br></pre></td></tr></table></figure><h3 id="常用标签语法"><a href="#常用标签语法" class="headerlink" title="常用标签语法"></a>常用标签语法</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 图片</span></span><br><span class="line">![<span class="string">图片描述</span>](<span class="link">图片链接</span>)</span><br><span class="line"></span><br><span class="line"><span class="section"># 链接</span></span><br><span class="line">[<span class="string">链接文字</span>](<span class="link">链接地址</span>)</span><br><span class="line"></span><br><span class="line"><span class="section"># 代码块</span></span><br><span class="line"><span class="code">```javascript</span></span><br><span class="line"><span class="code">console.log(&#x27;Hello World&#x27;);</span></span><br></pre></td></tr></table></figure><!-- # 引用> 引用内容# 表格| 列1 | 列2 | 列3 ||-----|-----|-----|| 内容1 | 内容2 | 内容3 | --><h2 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h2><h3 id="Next-主题常用配置"><a href="#Next-主题常用配置" class="headerlink" title="Next 主题常用配置"></a>Next 主题常用配置</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 主题设置</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 菜单设置</span></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">about</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 侧边栏设置</span></span><br><span class="line"><span class="attr">sidebar:</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">left</span></span><br><span class="line">  <span class="attr">display:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 社交链接</span></span><br><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">github:</span> <span class="string">https://github.com/yourname</span></span><br><span class="line">  <span class="attr">twitter:</span> <span class="string">https://twitter.com/yourname</span></span><br><span class="line">  <span class="attr">email:</span> <span class="string">your-email@example.com</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 评论系统</span></span><br><span class="line"><span class="attr">comments:</span></span><br><span class="line">  <span class="attr">active:</span> <span class="string">disqus</span></span><br><span class="line">  <span class="attr">shortname:</span> <span class="string">your-disqus-shortname</span></span><br></pre></td></tr></table></figure><h2 id="部署配置"><a href="#部署配置" class="headerlink" title="部署配置"></a>部署配置</h2><h3 id="GitHub-Pages-部署"><a href="#GitHub-Pages-部署" class="headerlink" title="GitHub Pages 部署"></a>GitHub Pages 部署</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/username/username.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br><span class="line">  <span class="attr">message:</span> <span class="string">&quot;Site updated: <span class="template-variable">&#123;&#123; now(&#x27;YYYY-MM-DD HH:mm:ss&#x27;) &#125;&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><h3 id="其他部署方式"><a href="#其他部署方式" class="headerlink" title="其他部署方式"></a>其他部署方式</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 部署到服务器</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">rsync</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">your-server.com</span></span><br><span class="line">  <span class="attr">user:</span> <span class="string">username</span></span><br><span class="line">  <span class="attr">root:</span> <span class="string">/var/www/</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">blog/</span></span><br><span class="line">  <span class="attr">delete:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署到腾讯云 COS</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">cos</span></span><br><span class="line">  <span class="attr">bucket:</span> <span class="string">your-bucket-name</span></span><br><span class="line">  <span class="attr">region:</span> <span class="string">ap-beijing</span></span><br><span class="line">  <span class="attr">secretId:</span> <span class="string">your-secret-id</span></span><br><span class="line">  <span class="attr">secretKey:</span> <span class="string">your-secret-key</span></span><br></pre></td></tr></table></figure><h2 id="插件推荐"><a href="#插件推荐" class="headerlink" title="插件推荐"></a>插件推荐</h2><h3 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 搜索插件</span></span><br><span class="line">npm install hexo-generator-search --save</span><br><span class="line"></span><br><span class="line"><span class="comment"># 站点地图</span></span><br><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line"></span><br><span class="line"><span class="comment"># RSS 订阅</span></span><br><span class="line">npm install hexo-generator-feed --save</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文章阅读时间统计</span></span><br><span class="line">npm install hexo-reading-time --save</span><br><span class="line"></span><br><span class="line"><span class="comment"># 图片懒加载</span></span><br><span class="line">npm install hexo-lazyload-image --save</span><br><span class="line"></span><br><span class="line"><span class="comment"># 代码高亮</span></span><br><span class="line">npm install hexo-prism-plugin --save</span><br></pre></td></tr></table></figure><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="图片优化"><a href="#图片优化" class="headerlink" title="图片优化"></a>图片优化</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装图片压缩插件</span></span><br><span class="line">npm install hexo-image-min --save</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置图片懒加载</span></span><br><span class="line">lazyload:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  onlypost: <span class="literal">false</span></span><br><span class="line">  loadingImg: /images/loading.gif</span><br></pre></td></tr></table></figure><h3 id="代码压缩"><a href="#代码压缩" class="headerlink" title="代码压缩"></a>代码压缩</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装压缩插件</span></span><br><span class="line">npm install hexo-html-minifier --save</span><br><span class="line">npm install hexo-clean-css --save</span><br><span class="line">npm install hexo-uglify --save</span><br></pre></td></tr></table></figure><hr><!-- *本文档会持续更新，如有问题欢迎交流讨论。* -->]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Hexo-静态博客框架使用指南&quot;&gt;&lt;a href=&quot;#Hexo-静态博客框架使用指南&quot; class=&quot;headerlink&quot; title=&quot;Hexo 静态博客框架使用指南&quot;&gt;&lt;/a&gt;Hexo 静态博客框架使用指南&lt;/h1&gt;&lt;p&gt;Hexo 是一个快速、简洁且高效的博</summary>
      
    
    
    
    
    <category term="Hexo" scheme="https://siyuewei.github.io/tags/Hexo/"/>
    
    <category term="博客" scheme="https://siyuewei.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="静态网站" scheme="https://siyuewei.github.io/tags/%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99/"/>
    
    <category term="教程" scheme="https://siyuewei.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Tools</title>
    <link href="https://siyuewei.github.io/2025/09/04/Tools/Tools/"/>
    <id>https://siyuewei.github.io/2025/09/04/Tools/Tools/</id>
    <published>2025-09-03T16:33:45.000Z</published>
    <updated>2025-10-28T15:55:20.104Z</updated>
    
    <content type="html"><![CDATA[<h1 id="妙妙工具合集"><a href="#妙妙工具合集" class="headerlink" title="妙妙工具合集"></a>妙妙工具合集</h1><p><a href="https://realfavicongenerator.net/">https://realfavicongenerator.net/</a> 上传一张图片，生成浏览器图片所需的图片格式</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;妙妙工具合集&quot;&gt;&lt;a href=&quot;#妙妙工具合集&quot; class=&quot;headerlink&quot; title=&quot;妙妙工具合集&quot;&gt;&lt;/a&gt;妙妙工具合集&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://realfavicongenerator.net/&quot;&gt;https://re</summary>
      
    
    
    
    
    <category term="Tools" scheme="https://siyuewei.github.io/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>Rendering ToolTips</title>
    <link href="https://siyuewei.github.io/2025/09/03/Rendering/Rendering/"/>
    <id>https://siyuewei.github.io/2025/09/03/Rendering/Rendering/</id>
    <published>2025-09-02T19:21:11.000Z</published>
    <updated>2025-10-28T15:55:18.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用软件"><a href="#常用软件" class="headerlink" title="常用软件"></a>常用软件</h1><ul><li>renderDoc：支持对应用截帧分析</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;常用软件&quot;&gt;&lt;a href=&quot;#常用软件&quot; class=&quot;headerlink&quot; title=&quot;常用软件&quot;&gt;&lt;/a&gt;常用软件&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;renderDoc：支持对应用截帧分析&lt;/li&gt;
&lt;/ul&gt;
</summary>
      
    
    
    
    <category term="Rendering" scheme="https://siyuewei.github.io/categories/Rendering/"/>
    
    
    <category term="Rendering" scheme="https://siyuewei.github.io/tags/Rendering/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://siyuewei.github.io/2025/09/03/hello-world/"/>
    <id>https://siyuewei.github.io/2025/09/03/hello-world/</id>
    <published>2025-09-02T18:27:43.281Z</published>
    <updated>2025-09-02T18:27:43.282Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
